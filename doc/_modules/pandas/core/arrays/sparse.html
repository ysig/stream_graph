

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pandas.core.arrays.sparse &mdash; Stream Graph 0.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/_static/css/supplementary.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Stream Graph
          

          
            
            <img src="../../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../package_walkthrough/index.html">Package Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../auto_examples/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction/about.html">General Information</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html">ABC Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html#base-classes">Base Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html#abc-implementations">ABC Implementations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html#temporal-dataframes">Temporal-DataFrames</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html#visualizer">Visualizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html#exceptions">Exceptions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Stream Graph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>pandas.core.arrays.sparse</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pandas.core.arrays.sparse</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SparseArray data structure</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">abc</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="k">import</span> <span class="n">index</span> <span class="k">as</span> <span class="n">libindex</span><span class="p">,</span> <span class="n">lib</span>
<span class="kn">import</span> <span class="nn">pandas._libs.sparse</span> <span class="k">as</span> <span class="nn">splib</span>
<span class="kn">from</span> <span class="nn">pandas._libs.sparse</span> <span class="k">import</span> <span class="n">BlockIndex</span><span class="p">,</span> <span class="n">IntIndex</span><span class="p">,</span> <span class="n">SparseIndex</span>
<span class="kn">from</span> <span class="nn">pandas._libs.tslibs</span> <span class="k">import</span> <span class="n">NaT</span>
<span class="kn">import</span> <span class="nn">pandas.compat</span> <span class="k">as</span> <span class="nn">compat</span>
<span class="kn">from</span> <span class="nn">pandas.compat._optional</span> <span class="k">import</span> <span class="n">import_optional_dependency</span>
<span class="kn">from</span> <span class="nn">pandas.compat.numpy</span> <span class="k">import</span> <span class="n">function</span> <span class="k">as</span> <span class="n">nv</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="k">import</span> <span class="n">PerformanceWarning</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.base</span> <span class="k">import</span> <span class="n">ExtensionDtype</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.cast</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">astype_nansafe</span><span class="p">,</span>
    <span class="n">construct_1d_arraylike_from_scalar</span><span class="p">,</span>
    <span class="n">find_common_type</span><span class="p">,</span>
    <span class="n">infer_dtype_from_scalar</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">is_array_like</span><span class="p">,</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64_any_dtype</span><span class="p">,</span>
    <span class="n">is_dtype_equal</span><span class="p">,</span>
    <span class="n">is_integer</span><span class="p">,</span>
    <span class="n">is_object_dtype</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">is_string_dtype</span><span class="p">,</span>
    <span class="n">pandas_dtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.dtypes</span> <span class="k">import</span> <span class="n">register_extension_dtype</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">ABCIndexClass</span><span class="p">,</span>
    <span class="n">ABCSeries</span><span class="p">,</span>
    <span class="n">ABCSparseArray</span><span class="p">,</span>
    <span class="n">ABCSparseSeries</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="k">import</span> <span class="n">isna</span><span class="p">,</span> <span class="n">na_value_for_dtype</span><span class="p">,</span> <span class="n">notna</span>

<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="k">import</span> <span class="n">Dtype</span>
<span class="kn">from</span> <span class="nn">pandas.core.accessor</span> <span class="k">import</span> <span class="n">PandasDelegate</span><span class="p">,</span> <span class="n">delegate_names</span>
<span class="kn">import</span> <span class="nn">pandas.core.algorithms</span> <span class="k">as</span> <span class="nn">algos</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="k">import</span> <span class="n">ExtensionArray</span><span class="p">,</span> <span class="n">ExtensionOpsMixin</span>
<span class="kn">from</span> <span class="nn">pandas.core.base</span> <span class="k">import</span> <span class="n">PandasObject</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">from</span> <span class="nn">pandas.core.missing</span> <span class="k">import</span> <span class="n">interpolate_2d</span>
<span class="kn">import</span> <span class="nn">pandas.core.ops</span> <span class="k">as</span> <span class="nn">ops</span>

<span class="kn">import</span> <span class="nn">pandas.io.formats.printing</span> <span class="k">as</span> <span class="nn">printing</span>


<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1"># Dtype</span>
<span class="nd">@register_extension_dtype</span>
<span class="k">class</span> <span class="nc">SparseDtype</span><span class="p">(</span><span class="n">ExtensionDtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dtype for data stored in :class:`SparseArray`.</span>

<span class="sd">    This dtype implements the pandas ExtensionDtype interface.</span>

<span class="sd">    .. versionadded:: 0.24.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dtype : str, ExtensionDtype, numpy.dtype, type, default numpy.float64</span>
<span class="sd">        The dtype of the underlying array storing the non-fill value values.</span>
<span class="sd">    fill_value : scalar, optional</span>
<span class="sd">        The scalar value not stored in the SparseArray. By default, this</span>
<span class="sd">        depends on `dtype`.</span>

<span class="sd">        =========== ==========</span>
<span class="sd">        dtype       na_value</span>
<span class="sd">        =========== ==========</span>
<span class="sd">        float       ``np.nan``</span>
<span class="sd">        int         ``0``</span>
<span class="sd">        bool        ``False``</span>
<span class="sd">        datetime64  ``pd.NaT``</span>
<span class="sd">        timedelta64 ``pd.NaT``</span>
<span class="sd">        =========== ==========</span>

<span class="sd">        The default value may be overridden by specifying a `fill_value`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    None</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># We include `_is_na_fill_value` in the metadata to avoid hash collisions</span>
    <span class="c1"># between SparseDtype(float, 0.0) and SparseDtype(float, nan).</span>
    <span class="c1"># Without is_na_fill_value in the comparison, those would be equal since</span>
    <span class="c1"># hash(nan) is (sometimes?) 0.</span>
    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_dtype&quot;</span><span class="p">,</span> <span class="s2">&quot;_fill_value&quot;</span><span class="p">,</span> <span class="s2">&quot;_is_na_fill_value&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="k">import</span> <span class="n">na_value_for_dtype</span>
        <span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="k">import</span> <span class="n">pandas_dtype</span><span class="p">,</span> <span class="n">is_string_dtype</span><span class="p">,</span> <span class="n">is_scalar</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">fill_value</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_string_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">na_value_for_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;fill_value must be a scalar. Got </span><span class="si">{}</span><span class="s2"> &quot;</span> <span class="s2">&quot;instead&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Python3 doesn&#39;t inherit __hash__ when a base class overrides</span>
        <span class="c1"># __eq__, so we explicitly do it here.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># We have to override __eq__ to handle NA values in _metadata.</span>
        <span class="c1"># The base class does simple == checks, which fail for NA.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_from_string</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">subtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtype</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">subtype</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_na_fill_value</span><span class="p">:</span>
                <span class="c1"># this case is complicated by two things:</span>
                <span class="c1"># SparseDtype(float, float(nan)) == SparseDtype(float, np.nan)</span>
                <span class="c1"># SparseDtype(float, np.nan)     != SparseDtype(float, pd.NaT)</span>
                <span class="c1"># i.e. we want to treat any floating-point NaN as equal, but</span>
                <span class="c1"># not a floating-point NaN and a datetime NaT.</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">_is_na_fill_value</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>
                    <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">fill_value</span>

            <span class="k">return</span> <span class="n">subtype</span> <span class="ow">and</span> <span class="n">fill_value</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The fill value of the array.</span>

<span class="sd">        Converting the SparseArray to a dense ndarray will fill the</span>
<span class="sd">        array with this value.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           It&#39;s possible to end up with a SparseArray that has ``fill_value``</span>
<span class="sd">           values in ``sp_values``. This can occur, for example, when setting</span>
<span class="sd">           ``SparseArray.fill_value`` directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_na_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="k">import</span> <span class="n">isna</span>

        <span class="k">return</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_numeric</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="k">import</span> <span class="n">is_object_dtype</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtype</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_boolean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="k">import</span> <span class="n">is_bool_dtype</span>

        <span class="k">return</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtype</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The sparse kind. Either &#39;integer&#39;, or &#39;block&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtype</span><span class="o">.</span><span class="n">kind</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtype</span><span class="o">.</span><span class="n">type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">subtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Sparse[</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtype</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">construct_array_type</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SparseArray</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">construct_from_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a SparseDtype from a string form.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        string : str</span>
<span class="sd">            Can take the following forms.</span>

<span class="sd">            string           dtype</span>
<span class="sd">            ================ ============================</span>
<span class="sd">            &#39;int&#39;            SparseDtype[np.int64, 0]</span>
<span class="sd">            &#39;Sparse&#39;         SparseDtype[np.float64, nan]</span>
<span class="sd">            &#39;Sparse[int]&#39;    SparseDtype[np.int64, 0]</span>
<span class="sd">            &#39;Sparse[int, 0]&#39; SparseDtype[np.int64, 0]</span>
<span class="sd">            ================ ============================</span>

<span class="sd">            It is not possible to specify non-default fill values</span>
<span class="sd">            with a string. An argument like ``&#39;Sparse[int, 1]&#39;``</span>
<span class="sd">            will raise a ``TypeError`` because the default fill value</span>
<span class="sd">            for integers is 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseDtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Could not construct SparseDtype from &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">string</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Sparse&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sub_type</span><span class="p">,</span> <span class="n">has_fill_value</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_subtype</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">SparseDtype</span><span class="p">(</span><span class="n">sub_type</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Could not construct SparseDtype from &#39;</span><span class="si">{}</span><span class="s2">&#39;.</span><span class="se">\n\n</span><span class="s2">It &quot;</span>
                    <span class="s2">&quot;looks like the fill_value in the string is not &quot;</span>
                    <span class="s2">&quot;the default for the dtype. Non-default fill_values &quot;</span>
                    <span class="s2">&quot;are not supported. Use the &#39;SparseDtype()&#39; &quot;</span>
                    <span class="s2">&quot;constructor instead.&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">has_fill_value</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">!=</span> <span class="n">string</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_subtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse a string to get the subtype</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : str</span>
<span class="sd">            A string like</span>

<span class="sd">            * Sparse[subtype]</span>
<span class="sd">            * Sparse[subtype, fill_value]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subtype : str</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When the subtype cannot be extracted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xpr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Sparse\[(?P&lt;subtype&gt;[^,]*)(, )?(?P&lt;fill_value&gt;.*?)?\]$&quot;</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">xpr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">has_fill_value</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">subtype</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s2">&quot;subtype&quot;</span><span class="p">]</span>
            <span class="n">has_fill_value</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s2">&quot;fill_value&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">has_fill_value</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;Sparse&quot;</span><span class="p">:</span>
            <span class="n">subtype</span> <span class="o">=</span> <span class="s2">&quot;float64&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot parse </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">subtype</span><span class="p">,</span> <span class="n">has_fill_value</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">is_dtype</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dtype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;Sparse&quot;</span><span class="p">):</span>
            <span class="n">sub_type</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_subtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">sub_type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;Sparse&quot;</span>

    <span class="k">def</span> <span class="nf">update_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the SparseDtype to a new dtype.</span>

<span class="sd">        This takes care of converting the ``fill_value``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : Union[str, numpy.dtype, SparseDtype]</span>
<span class="sd">            The new dtype to use.</span>

<span class="sd">            * For a SparseDtype, it is simply returned</span>
<span class="sd">            * For a NumPy dtype (or str), the current fill value</span>
<span class="sd">              is converted to the new dtype, and a SparseDtype</span>
<span class="sd">              with `dtype` and the new fill value is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseDtype</span>
<span class="sd">            A new SparseDtype with the corret `dtype` and fill value</span>
<span class="sd">            for that `dtype`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            When the current fill value cannot be converted to the</span>
<span class="sd">            new `dtype` (e.g. trying to convert ``np.nan`` to an</span>
<span class="sd">            integer dtype).</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; SparseDtype(int, 0).update_dtype(float)</span>
<span class="sd">        Sparse[float64, 0.0]</span>

<span class="sd">        &gt;&gt;&gt; SparseDtype(int, 1).update_dtype(SparseDtype(float, np.nan))</span>
<span class="sd">        Sparse[float64, nan]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">astype_nansafe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_subtype_with_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the SparseDtype&#39;s subtype should be considered ``str``.</span>

<span class="sd">        Typically, pandas will store string data in an object-dtype array.</span>
<span class="sd">        When converting values to a dtype, e.g. in ``.astype``, we need to</span>
<span class="sd">        be more specific, we need the actual underlying type.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &gt;&gt;&gt; SparseDtype(int, 1)._subtype_with_str</span>
<span class="sd">        dtype(&#39;int64&#39;)</span>

<span class="sd">        &gt;&gt;&gt; SparseDtype(object, 1)._subtype_with_str</span>
<span class="sd">        dtype(&#39;O&#39;)</span>

<span class="sd">        &gt;&gt;&gt; dtype = SparseDtype(str, &#39;&#39;)</span>
<span class="sd">        &gt;&gt;&gt; dtype.subtype</span>
<span class="sd">        dtype(&#39;O&#39;)</span>

<span class="sd">        &gt;&gt;&gt; dtype._subtype_with_str</span>
<span class="sd">        str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtype</span>


<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1"># Array</span>


<span class="n">_sparray_doc_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="s2">&quot;SparseArray&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_fill</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ABCSparseArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a 0-dim ndarray containing the fill value</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : SparseArray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fill_value : ndarray</span>
<span class="sd">        0-dim ndarray with just the fill value.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    coerce fill_value to arr dtype if possible</span>
<span class="sd">    int64 SparseArray can have NaN as fill_value if there is no missing</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sparse_array_op</span><span class="p">(</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">ABCSparseArray</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">ABCSparseArray</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a binary operation between two arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : Union[SparseArray, ndarray]</span>
<span class="sd">    right : Union[SparseArray, ndarray]</span>
<span class="sd">    op : Callable</span>
<span class="sd">        The binary operation to perform</span>
<span class="sd">    name str</span>
<span class="sd">        Name of the callable.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SparseArray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">):</span>
        <span class="c1"># For lookups in _libs.sparse we need non-dunder op name</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># dtype used to find corresponding sparse method</span>
    <span class="n">ltype</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span>
    <span class="n">rtype</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="n">ltype</span><span class="p">,</span> <span class="n">rtype</span><span class="p">):</span>
        <span class="n">subtype</span> <span class="o">=</span> <span class="n">find_common_type</span><span class="p">([</span><span class="n">ltype</span><span class="p">,</span> <span class="n">rtype</span><span class="p">])</span>
        <span class="n">ltype</span> <span class="o">=</span> <span class="n">SparseDtype</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="n">rtype</span> <span class="o">=</span> <span class="n">SparseDtype</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="c1"># TODO(GH-23092): pass copy=False. Need to fix astype_nansafe</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ltype</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">rtype</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">ltype</span><span class="o">.</span><span class="n">subtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">ltype</span>

    <span class="c1"># dtype the result must have</span>
    <span class="n">result_dtype</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">ngaps</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">right</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">ngaps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">right</span><span class="o">.</span><span class="n">to_dense</span><span class="p">())</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">_get_fill</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">_get_fill</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">ngaps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">sp_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">sp_index</span>
    <span class="k">elif</span> <span class="n">left</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">sp_index</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">sp_values</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">sp_values</span><span class="p">)</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">_get_fill</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">_get_fill</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">sp_index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">,</span> <span class="n">left</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;and&quot;</span><span class="p">,</span> <span class="s2">&quot;or&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
            <span class="n">opname</span> <span class="o">=</span> <span class="s2">&quot;sparse_</span><span class="si">{name}</span><span class="s2">_uint8&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
            <span class="c1"># to make template simple, cast here</span>
            <span class="n">left_sp_values</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">sp_values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">right_sp_values</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">sp_values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">result_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">opname</span> <span class="o">=</span> <span class="s2">&quot;sparse_</span><span class="si">{name}</span><span class="s2">_</span><span class="si">{dtype}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">left_sp_values</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">sp_values</span>
            <span class="n">right_sp_values</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">sp_values</span>

        <span class="n">sparse_op</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">splib</span><span class="p">,</span> <span class="n">opname</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fill</span> <span class="o">=</span> <span class="n">sparse_op</span><span class="p">(</span>
                <span class="n">left_sp_values</span><span class="p">,</span>
                <span class="n">left</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span>
                <span class="n">left</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">right_sp_values</span><span class="p">,</span>
                <span class="n">right</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span>
                <span class="n">right</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">result_dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">result_dtype</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span>

    <span class="k">return</span> <span class="n">_wrap_result</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_wrap_result</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sparse_index</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    wrap op result to have correct dtype</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">):</span>
        <span class="c1"># e.g. __eq__ --&gt; eq</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;eq&quot;</span><span class="p">,</span> <span class="s2">&quot;ne&quot;</span><span class="p">,</span> <span class="s2">&quot;lt&quot;</span><span class="p">,</span> <span class="s2">&quot;gt&quot;</span><span class="p">,</span> <span class="s2">&quot;le&quot;</span><span class="p">,</span> <span class="s2">&quot;ge&quot;</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span>

    <span class="n">fill_value</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">item_from_zerodim</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
        <span class="c1"># fill_value may be np.bool_</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SparseArray</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">sparse_index</span><span class="o">=</span><span class="n">sparse_index</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">SparseArray</span><span class="p">(</span><span class="n">PandasObject</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">,</span> <span class="n">ExtensionOpsMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An ExtensionArray for storing sparse data.</span>

<span class="sd">    .. versionchanged:: 0.24.0</span>

<span class="sd">       Implements the ExtensionArray interface.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like</span>
<span class="sd">        A dense array of values to store in the SparseArray. This may contain</span>
<span class="sd">        `fill_value`.</span>
<span class="sd">    sparse_index : SparseIndex, optional</span>
<span class="sd">    index : Index</span>
<span class="sd">    fill_value : scalar, optional</span>
<span class="sd">        Elements in `data` that are `fill_value` are not stored in the</span>
<span class="sd">        SparseArray. For memory savings, this should be the most common value</span>
<span class="sd">        in `data`. By default, `fill_value` depends on the dtype of `data`:</span>

<span class="sd">        =========== ==========</span>
<span class="sd">        data.dtype  na_value</span>
<span class="sd">        =========== ==========</span>
<span class="sd">        float       ``np.nan``</span>
<span class="sd">        int         ``0``</span>
<span class="sd">        bool        False</span>
<span class="sd">        datetime64  ``pd.NaT``</span>
<span class="sd">        timedelta64 ``pd.NaT``</span>
<span class="sd">        =========== ==========</span>

<span class="sd">        The fill value is potentially specified in three ways. In order of</span>
<span class="sd">        precedence, these are</span>

<span class="sd">        1. The `fill_value` argument</span>
<span class="sd">        2. ``dtype.fill_value`` if `fill_value` is None and `dtype` is</span>
<span class="sd">           a ``SparseDtype``</span>
<span class="sd">        3. ``data.dtype.fill_value`` if `fill_value` is None and `dtype`</span>
<span class="sd">           is not a ``SparseDtype`` and `data` is a ``SparseArray``.</span>

<span class="sd">    kind : {&#39;integer&#39;, &#39;block&#39;}, default &#39;integer&#39;</span>
<span class="sd">        The type of storage for sparse locations.</span>

<span class="sd">        * &#39;block&#39;: Stores a `block` and `block_length` for each</span>
<span class="sd">          contiguous *span* of sparse values. This is best when</span>
<span class="sd">          sparse data tends to be clumped together, with large</span>
<span class="sd">          regions of ``fill-value`` values between sparse values.</span>
<span class="sd">        * &#39;integer&#39;: uses an integer to store the location of</span>
<span class="sd">          each sparse value.</span>

<span class="sd">    dtype : np.dtype or SparseDtype, optional</span>
<span class="sd">        The dtype to use for the SparseArray. For numpy dtypes, this</span>
<span class="sd">        determines the dtype of ``self.sp_values``. For SparseDtype,</span>
<span class="sd">        this determines ``self.sp_values`` and ``self.fill_value``.</span>
<span class="sd">    copy : bool, default False</span>
<span class="sd">        Whether to explicitly copy the incoming `data` array.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    None</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_pandas_ftype</span> <span class="o">=</span> <span class="s2">&quot;sparse&quot;</span>
    <span class="n">_subtyp</span> <span class="o">=</span> <span class="s2">&quot;sparse_array&quot;</span>  <span class="c1"># register ABCSparseArray</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">sparse_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;integer&quot;</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.internals</span> <span class="k">import</span> <span class="n">SingleBlockManager</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SingleBlockManager</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">internal_values</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">SparseDtype</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">fill_value</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">ABCSparseSeries</span><span class="p">)):</span>
            <span class="c1"># disable normal inference on dtype, sparse_index, &amp; fill_value</span>
            <span class="k">if</span> <span class="n">sparse_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sparse_index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sp_index</span>
            <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">fill_value</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
            <span class="c1"># TODO: make kind=None, and use data.kind?</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sp_values</span>

        <span class="c1"># Handle use-provided dtype</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Two options: dtype=&#39;int&#39;, regular numpy dtype</span>
            <span class="c1"># or dtype=&#39;Sparse[int]&#39;, a sparse dtype</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">SparseDtype</span><span class="o">.</span><span class="n">construct_from_string</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">SparseDtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">fill_value</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;must only pass scalars with an index &quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">npoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">sparse_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">npoints</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">npoints</span> <span class="o">=</span> <span class="n">sparse_index</span><span class="o">.</span><span class="n">length</span>

            <span class="n">dtype</span> <span class="o">=</span> <span class="n">infer_dtype_from_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">construct_1d_arraylike_from_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># TODO: disentangle the fill_value dtype inference from</span>
        <span class="c1"># dtype inference</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># XXX: What should the empty dtype be? Object or float?</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_array_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># probably shared code in sanitize_series</span>
                <span class="kn">from</span> <span class="nn">pandas.core.internals.construction</span> <span class="k">import</span> <span class="n">sanitize_array</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">sanitize_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># NumPy may raise a ValueError on data like [1, []]</span>
                <span class="c1"># we retry with object dtype here.</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="c1"># TODO: avoid double copy when dtype forces cast.</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_value_dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>
            <span class="k">if</span> <span class="n">fill_value_dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">na_value_for_dtype</span><span class="p">(</span><span class="n">fill_value_dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="ow">and</span> <span class="n">sparse_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sparse_index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_sparse_index</span>
            <span class="n">sparse_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">sp_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sparse_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sparse_values</span><span class="p">,</span> <span class="n">sparse_index</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">make_sparse</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sparse_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparse_values</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sparse_index</span><span class="o">.</span><span class="n">npoints</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;Non array-like type </span><span class="si">{type}</span><span class="s2"> must &quot;</span>
                    <span class="s2">&quot;have the same length as the index&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">sparse_values</span><span class="p">))</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_index</span> <span class="o">=</span> <span class="n">sparse_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_values</span> <span class="o">=</span> <span class="n">sparse_values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">SparseDtype</span><span class="p">(</span><span class="n">sparse_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_simple_new</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">sparse_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sparse_index</span><span class="p">:</span> <span class="n">SparseIndex</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">SparseDtype</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ABCSparseArray</span><span class="p">:</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">([])</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_sparse_index</span> <span class="o">=</span> <span class="n">sparse_index</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_sparse_values</span> <span class="o">=</span> <span class="n">sparse_array</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_spmatrix</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a SparseArray from a scipy.sparse matrix.</span>

<span class="sd">        .. versionadded:: 0.25.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : scipy.sparse.sp_matrix</span>
<span class="sd">            This should be a SciPy sparse matrix where the size</span>
<span class="sd">            of the second dimension is 1. In other words, a</span>
<span class="sd">            sparse matrix with a single column.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseArray</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import scipy.sparse</span>
<span class="sd">        &gt;&gt;&gt; mat = scipy.sparse.coo_matrix((4, 1))</span>
<span class="sd">        &gt;&gt;&gt; pd.SparseArray.from_spmatrix(mat)</span>
<span class="sd">        [0.0, 0.0, 0.0, 0.0]</span>
<span class="sd">        Fill: 0.0</span>
<span class="sd">        IntIndex</span>
<span class="sd">        Indices: array([], dtype=int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length</span><span class="p">,</span> <span class="n">ncol</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">ncol</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;data&#39; must have a single column, not &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ncol</span><span class="p">))</span>

        <span class="c1"># our sparse index classes require that the positions be strictly</span>
        <span class="c1"># increasing. So we need to sort loc, and arr accordingly.</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">SparseDtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">zero</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">IntIndex</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">ngaps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Compat for na dtype and int values.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Can NumPy represent this type?</span>
            <span class="c1"># If not, `np.result_type` will raise. We catch that</span>
            <span class="c1"># and return object.</span>
            <span class="k">if</span> <span class="n">is_datetime64_any_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># However, we *do* special-case the common case of</span>
                <span class="c1"># a datetime64 with pandas NaT.</span>
                <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="n">NaT</span><span class="p">:</span>
                    <span class="c1"># Can&#39;t put pd.NaT in a datetime64[ns]</span>
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;NaT&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">to_int_index</span><span class="p">()</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># I suppose we could allow setting of non-fill_value elements.</span>
        <span class="c1"># TODO(SparseArray.__setitem__): remove special cases in</span>
        <span class="c1"># ExtensionBlock.where</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;SparseArray does not support item assignment via setitem&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_sequence</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">scalars</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_factorized</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">original</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">original</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Data</span>
    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sp_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The SparseIndex containing the location of non- ``fill_value`` points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sp_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An ndarray containing the non- ``fill_value`` values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = SparseArray([0, 0, 1, 0, 2], fill_value=0)</span>
<span class="sd">        &gt;&gt;&gt; s.sp_values</span>
<span class="sd">        array([1, 2])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Elements in `data` that are `fill_value` are not stored.</span>

<span class="sd">        For memory savings, this should be the most common value in the array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fill_value</span>

    <span class="nd">@fill_value</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">SparseDtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The kind of sparse index for this array. One of {&#39;integer&#39;, &#39;block&#39;}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">IntIndex</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;integer&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;block&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_valid_sp_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sp_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">sp_vals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sp_vals</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">length</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_null_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="o">.</span><span class="n">_is_na_fill_value</span>

    <span class="k">def</span> <span class="nf">_fill_value_matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_null_fill_value</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">isna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">==</span> <span class="n">fill_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">nbytes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The percent of non- ``fill_value`` points, as decimal.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = SparseArray([0, 0, 1, 1, 1], fill_value=0)</span>
<span class="sd">        &gt;&gt;&gt; s.density</span>
<span class="sd">        0.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">npoints</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">npoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of non- ``fill_value`` points.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = SparseArray([0, 0, 1, 1, 1], fill_value=0)</span>
<span class="sd">        &gt;&gt;&gt; s.npoints</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">npoints</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dense values</span>

<span class="sd">        .. deprecated:: 0.25.0</span>

<span class="sd">            Use ``np.asarray(...)`` or the ``.to_dense()`` method instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;The SparseArray.values attribute is deprecated and will be &quot;</span>
            <span class="s2">&quot;removed in a future version. You can use `np.asarray(...)` or &quot;</span>
            <span class="s2">&quot;the `.to_dense()` method instead.&quot;</span>
        <span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">isna</span>

        <span class="c1"># If null fill value, we want SparseDtype[bool, true]</span>
        <span class="c1"># to preserve the same memory usage.</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">SparseDtype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_null_fill_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill missing values with `value`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, optional</span>
<span class="sd">        method : str, optional</span>

<span class="sd">            .. warning::</span>

<span class="sd">               Using &#39;method&#39; will result in high memory use,</span>
<span class="sd">               as all `fill_value` methods will be converted to</span>
<span class="sd">               an in-memory ndarray</span>

<span class="sd">        limit : int, optional</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseArray</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When `value` is specified, the result&#39;s ``fill_value`` depends on</span>
<span class="sd">        ``self.fill_value``. The goal is to maintain low-memory use.</span>

<span class="sd">        If ``self.fill_value`` is NA, the result dtype will be</span>
<span class="sd">        ``SparseDtype(self.dtype, fill_value=value)``. This will preserve</span>
<span class="sd">        amount of memory used before and after filling.</span>

<span class="sd">        When ``self.fill_value`` is not NA, the result dtype will be</span>
<span class="sd">        ``self.dtype``. Again, this preserves the amount of memory used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify one of &#39;method&#39; or &#39;value&#39;.&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;fillna with &#39;method&#39; requires high memory usage.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">PerformanceWarning</span><span class="p">)</span>
            <span class="n">filled</span> <span class="o">=</span> <span class="n">interpolate_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">filled</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">),</span> <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_null_fill_value</span><span class="p">:</span>
                <span class="c1"># This is essentially just updating the dtype.</span>
                <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">SparseDtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_index</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">isna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">na_value</span>

        <span class="n">subtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">subtype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">:</span>
            <span class="c1"># just coerce up front</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">SparseDtype</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">empty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span>
            <span class="p">[</span><span class="n">fill_value</span><span class="p">]</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">periods</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">periods</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">empty</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="n">periods</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span> <span class="p">:]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">empty</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">_concat_same_type</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_first_fill_value_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the location of the first missing value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">npoints</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">to_int_index</span><span class="p">()</span><span class="o">.</span><span class="n">indices</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="ow">or</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">diff</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">uniques</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">algos</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">))</span>
        <span class="n">fill_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_fill_value_loc</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fill_loc</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">uniques</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">fill_loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span><span class="n">uniques</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_values_for_factorize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Still override this for hash_pandas_object</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>

    <span class="k">def</span> <span class="nf">factorize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">na_sentinel</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Currently, ExtensionArray.factorize -&gt; Tuple[ndarray, EA]</span>
        <span class="c1"># The sparsity on this is backwards from what Sparse would want. Want</span>
        <span class="c1"># ExtensionArray.factorize -&gt; Tuple[EA, EA]</span>
        <span class="c1"># Given that we have to return a dense array of labels, why bother</span>
        <span class="c1"># implementing an efficient factorize?</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">uniques</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">na_sentinel</span><span class="o">=</span><span class="n">na_sentinel</span><span class="p">)</span>
        <span class="n">uniques</span> <span class="o">=</span> <span class="n">SparseArray</span><span class="p">(</span><span class="n">uniques</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span><span class="p">,</span> <span class="n">uniques</span>

    <span class="k">def</span> <span class="nf">value_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Series containing counts of unique values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dropna : boolean, default True</span>
<span class="sd">            Don&#39;t include counts of NaN, even if NaN is in sp_values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        counts : Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Index</span><span class="p">,</span> <span class="n">Series</span>

        <span class="n">keys</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">_value_counts_arraylike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>
        <span class="n">fcounts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">ngaps</span>
        <span class="k">if</span> <span class="n">fcounts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_null_fill_value</span> <span class="ow">and</span> <span class="n">dropna</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_null_fill_value</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">keys</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>

                <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fcounts</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>
                    <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fcounts</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># --------</span>
    <span class="c1"># Indexing</span>
    <span class="c1"># --------</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;too many indices for array.&quot;</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_val_at</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">data_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="c1"># special case to preserve dtypes</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># TODO: this logic is surely elsewhere</span>
            <span class="c1"># TODO: this could be more efficient</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: I think we can avoid densifying when masking a</span>
            <span class="c1"># boolean SparseArray with another. Need to look at the</span>
            <span class="c1"># key&#39;s fill_value for True / False, and then do an intersection</span>
            <span class="c1"># on the indicies of the sp_values.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">SparseArray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)[</span><span class="n">key</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot slice with &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">data_slice</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_val_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">+=</span> <span class="n">n</span>

        <span class="k">if</span> <span class="n">loc</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Out of bounds access&quot;</span><span class="p">)</span>

        <span class="n">sp_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sp_loc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">libindex</span><span class="o">.</span><span class="n">get_value_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">,</span> <span class="n">sp_loc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">allow_fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;indices&#39; must be an array, not a &quot;</span> <span class="s2">&quot;scalar &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">allow_fill</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_with_fill</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_without_fill</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">}</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_take_with_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">na_value</span>

        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid value in &#39;indices&#39;. Must be between -1 &quot;</span>
                <span class="s2">&quot;and the length of the array.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;out of bounds value in &#39;indices&#39;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Empty... Allow taking only if all empty</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
                <span class="n">taken</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">taken</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">taken</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;cannot do a non-empty take from an empty &quot;</span> <span class="s2">&quot;axes.&quot;</span><span class="p">)</span>

        <span class="n">sp_indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">lookup_array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">npoints</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Avoid taking from the empty self.sp_values</span>
            <span class="n">taken</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                <span class="n">sp_indexer</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">taken</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">sp_indexer</span><span class="p">)</span>

            <span class="c1"># sp_indexer may be -1 for two reasons</span>
            <span class="c1"># 1.) we took for an index of -1 (new)</span>
            <span class="c1"># 2.) we took a value that was self.fill_value (old)</span>
            <span class="n">new_fill_indices</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">old_fill_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp_indexer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">new_fill_indices</span>

            <span class="c1"># Fill in two steps.</span>
            <span class="c1"># Old fill values</span>
            <span class="c1"># New fill values</span>
            <span class="c1"># potentially coercing to a new dtype at each stage.</span>

            <span class="n">m0</span> <span class="o">=</span> <span class="n">sp_indexer</span><span class="p">[</span><span class="n">old_fill_indices</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">sp_indexer</span><span class="p">[</span><span class="n">new_fill_indices</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>

            <span class="n">result_type</span> <span class="o">=</span> <span class="n">taken</span><span class="o">.</span><span class="n">dtype</span>

            <span class="k">if</span> <span class="n">m0</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">result_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">result_type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>
                <span class="n">taken</span> <span class="o">=</span> <span class="n">taken</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_type</span><span class="p">)</span>
                <span class="n">taken</span><span class="p">[</span><span class="n">old_fill_indices</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>

            <span class="k">if</span> <span class="n">m1</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">result_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">result_type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
                <span class="n">taken</span> <span class="o">=</span> <span class="n">taken</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_type</span><span class="p">)</span>
                <span class="n">taken</span><span class="p">[</span><span class="n">new_fill_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>

        <span class="k">return</span> <span class="n">taken</span>

    <span class="k">def</span> <span class="nf">_take_without_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="n">to_shift</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;cannot do a non-empty take from an &quot;</span> <span class="s2">&quot;empty axes.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;out of bounds value in &#39;indices&#39;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">to_shift</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">to_shift</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">npoints</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># edge case in take...</span>
            <span class="c1"># I think just return</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)),</span>
            <span class="p">)</span>
            <span class="n">arr</span><span class="p">,</span> <span class="n">sp_index</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">make_sparse</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">arr</span><span class="p">,</span> <span class="n">sparse_index</span><span class="o">=</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="n">sp_indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">lookup_array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">taken</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">sp_indexer</span><span class="p">)</span>
        <span class="n">fillable</span> <span class="o">=</span> <span class="n">sp_indexer</span> <span class="o">&lt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">fillable</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># TODO: may need to coerce array to fill value</span>
            <span class="n">result_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">taken</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>
            <span class="n">taken</span> <span class="o">=</span> <span class="n">taken</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_type</span><span class="p">)</span>
            <span class="n">taken</span><span class="p">[</span><span class="n">fillable</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>

        <span class="k">return</span> <span class="n">taken</span>

    <span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;searchsorted requires high memory usage.&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">PerformanceWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span><span class="p">)</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">sorter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_concat_same_type</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">to_concat</span><span class="p">):</span>
        <span class="n">fill_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">fill_value</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">to_concat</span><span class="p">]</span>

        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># np.nan isn&#39;t a singleton, so we may end up with multiple</span>
        <span class="c1"># NaNs here, so we ignore tha all NA case too.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">fill_values</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">isna</span><span class="p">(</span><span class="n">fill_values</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Concatenating sparse arrays with multiple fill &quot;</span>
                <span class="s2">&quot;values: &#39;</span><span class="si">{}</span><span class="s2">&#39;. Picking the first and &quot;</span>
                <span class="s2">&quot;converting the rest.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fill_values</span><span class="p">),</span>
                <span class="n">PerformanceWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">to_concat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">to_concat2</span> <span class="o">=</span> <span class="p">[</span><span class="n">keep</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">to_concat</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">to_concat2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">))</span>

            <span class="n">to_concat</span> <span class="o">=</span> <span class="n">to_concat2</span>

        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">to_concat</span><span class="p">:</span>
            <span class="n">sp_kind</span> <span class="o">=</span> <span class="n">to_concat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sp_kind</span> <span class="o">=</span> <span class="s2">&quot;integer&quot;</span>

        <span class="k">if</span> <span class="n">sp_kind</span> <span class="o">==</span> <span class="s2">&quot;integer&quot;</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">to_concat</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">to_int_index</span><span class="p">()</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="n">length</span>  <span class="c1"># TODO: wraparound</span>
                <span class="n">length</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">length</span>

                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">sp_values</span><span class="p">)</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">sp_index</span> <span class="o">=</span> <span class="n">IntIndex</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># when concatenating block indices, we don&#39;t claim that you&#39;ll</span>
            <span class="c1"># get an identical index as concating the values and then</span>
            <span class="c1"># creating a new index. We don&#39;t want to spend the time trying</span>
            <span class="c1"># to merge blocks across arrays in `to_concat`, so the resulting</span>
            <span class="c1"># BlockIndex may have more blocs.</span>
            <span class="n">blengths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">blocs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">to_concat</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">to_block_index</span><span class="p">()</span>

                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">sp_values</span><span class="p">)</span>
                <span class="n">blocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">blocs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span>
                <span class="n">blengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">blengths</span><span class="p">)</span>
                <span class="n">length</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">length</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">blocs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">blocs</span><span class="p">)</span>
            <span class="n">blengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">blengths</span><span class="p">)</span>

            <span class="n">sp_index</span> <span class="o">=</span> <span class="n">BlockIndex</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">blocs</span><span class="p">,</span> <span class="n">blengths</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sparse_index</span><span class="o">=</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the dtype of a SparseArray.</span>

<span class="sd">        The output will always be a SparseArray. To convert to a dense</span>
<span class="sd">        ndarray with a certain dtype, use :meth:`numpy.asarray`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : np.dtype or ExtensionDtype</span>
<span class="sd">            For SparseDtype, this changes the dtype of</span>
<span class="sd">            ``self.sp_values`` and the ``self.fill_value``.</span>

<span class="sd">            For other dtypes, this only changes the dtype of</span>
<span class="sd">            ``self.sp_values``.</span>

<span class="sd">        copy : bool, default True</span>
<span class="sd">            Whether to ensure a copy is made, even if not necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseArray</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; arr = SparseArray([0, 0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; arr</span>
<span class="sd">        [0, 0, 1, 2]</span>
<span class="sd">        Fill: 0</span>
<span class="sd">        IntIndex</span>
<span class="sd">        Indices: array([2, 3], dtype=int32)</span>

<span class="sd">        &gt;&gt;&gt; arr.astype(np.dtype(&#39;int32&#39;))</span>
<span class="sd">        [0, 0, 1, 2]</span>
<span class="sd">        Fill: 0</span>
<span class="sd">        IntIndex</span>
<span class="sd">        Indices: array([2, 3], dtype=int32)</span>

<span class="sd">        Using a NumPy dtype with a different kind (e.g. float) will coerce</span>
<span class="sd">        just ``self.sp_values``.</span>

<span class="sd">        &gt;&gt;&gt; arr.astype(np.dtype(&#39;float64&#39;))</span>
<span class="sd">        ... # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [0, 0, 1.0, 2.0]</span>
<span class="sd">        Fill: 0</span>
<span class="sd">        IntIndex</span>
<span class="sd">        Indices: array([2, 3], dtype=int32)</span>

<span class="sd">        Use a SparseDtype if you wish to be change the fill value as well.</span>

<span class="sd">        &gt;&gt;&gt; arr.astype(SparseDtype(&quot;float64&quot;, fill_value=np.nan))</span>
<span class="sd">        ... # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [nan, nan, 1.0, 2.0]</span>
<span class="sd">        Fill: nan</span>
<span class="sd">        IntIndex</span>
<span class="sd">        Indices: array([2, 3], dtype=int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">update_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">subtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">_subtype_with_str</span>
        <span class="n">sp_values</span> <span class="o">=</span> <span class="n">astype_nansafe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">,</span> <span class="n">subtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sp_values</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span> <span class="ow">and</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">sp_values</span> <span class="o">=</span> <span class="n">sp_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">sp_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map categories using input correspondence (dict, Series, or function).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapper : dict, Series, callable</span>
<span class="sd">            The correspondence from old values to new.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseArray</span>
<span class="sd">            The output array will have the same density as the input.</span>
<span class="sd">            The output fill value will be the result of applying the</span>
<span class="sd">            mapping to ``self.fill_value``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; arr = pd.SparseArray([0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; arr.apply(lambda x: x + 10)</span>
<span class="sd">        [10, 11, 12]</span>
<span class="sd">        Fill: 10</span>
<span class="sd">        IntIndex</span>
<span class="sd">        Indices: array([1, 2], dtype=int32)</span>

<span class="sd">        &gt;&gt;&gt; arr.apply({0: 10, 1: 11, 2: 12})</span>
<span class="sd">        [10, 11, 12]</span>
<span class="sd">        Fill: 10</span>
<span class="sd">        IntIndex</span>
<span class="sd">        Indices: array([1, 2], dtype=int32)</span>

<span class="sd">        &gt;&gt;&gt; arr.apply(pd.Series([10, 11, 12], index=[0, 1, 2]))</span>
<span class="sd">        [10, 11, 12]</span>
<span class="sd">        Fill: 10</span>
<span class="sd">        IntIndex</span>
<span class="sd">        Indices: array([1, 2], dtype=int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this is used in apply.</span>
        <span class="c1"># We get hit since we&#39;re an &quot;is_extension_type&quot; but regular extension</span>
        <span class="c1"># types are not hit. This may be worth adding to the interface.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="n">mapper</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="n">sp_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">mapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="n">sp_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">mapper</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">sp_values</span><span class="p">,</span> <span class="n">sparse_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert SparseArray to a NumPy array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arr : NumPy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert SparseArray to a NumPy array.</span>

<span class="sd">        .. deprecated:: 0.25.0</span>
<span class="sd">            Use `to_dense` instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The &#39;get_values&#39; method is deprecated and will be removed in a &quot;</span>
            <span class="s2">&quot;future version. Use the &#39;to_dense&#39; method instead.&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_get_values</span><span class="p">()</span>

    <span class="n">_internal_get_values</span> <span class="o">=</span> <span class="n">to_dense</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># IO</span>
    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Necessary for making this object picklable&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># Compat for pandas &lt; 0.24.0</span>
            <span class="n">nd_state</span><span class="p">,</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">sp_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span>
            <span class="n">sparse_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="n">sparse_values</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">nd_state</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_values</span> <span class="o">=</span> <span class="n">sparse_values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_index</span> <span class="o">=</span> <span class="n">sp_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">SparseDtype</span><span class="p">(</span><span class="n">sparse_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">to_int_index</span><span class="p">()</span><span class="o">.</span><span class="n">indices</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">to_int_index</span><span class="p">()</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],)</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Reductions</span>
    <span class="c1"># ------------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot perform </span><span class="si">{name}</span><span class="s2"> with type </span><span class="si">{dtype}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">skipna</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>

        <span class="c1"># we don&#39;t support these kwargs.</span>
        <span class="c1"># They should only be present when called via pandas, so do it here.</span>
        <span class="c1"># instead of in `any` / `all` (which will raise if they&#39;re present,</span>
        <span class="c1"># thanks to nv.validate</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;filter_type&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;numeric_only&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;op&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">name</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests whether all elements evaluate True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        all : bool</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.all</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_all</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests whether at least one of elements evaluate True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        any : bool</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_any</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sum of non-NA/null values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sum : float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_sum</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">valid_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_sp_values</span>
        <span class="n">sp_sum</span> <span class="o">=</span> <span class="n">valid_vals</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_null_fill_value</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sp_sum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nsparse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">ngaps</span>
            <span class="k">return</span> <span class="n">sp_sum</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">*</span> <span class="n">nsparse</span>

    <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cumulative sum of non-NA/null values.</span>

<span class="sd">        When performing the cumulative summation, any non-NA/null values will</span>
<span class="sd">        be skipped. The resulting SparseArray will preserve the locations of</span>
<span class="sd">        NaN values, but the fill value will be `np.nan` regardless.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int or None</span>
<span class="sd">            Axis over which to perform the cumulative summation. If None,</span>
<span class="sd">            perform cumulative summation over flattened array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cumsum : SparseArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_cumsum</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>  <span class="c1"># Mimic ndarray behaviour.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axis(=</span><span class="si">{axis}</span><span class="s2">) out of bounds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_null_fill_value</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SparseArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dense</span><span class="p">())</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">SparseArray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(),</span>
            <span class="n">sparse_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mean of non-NA/null values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean : float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_mean</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">valid_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_sp_values</span>
        <span class="n">sp_sum</span> <span class="o">=</span> <span class="n">valid_vals</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_vals</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_null_fill_value</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sp_sum</span> <span class="o">/</span> <span class="n">ct</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nsparse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">ngaps</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">sp_sum</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">*</span> <span class="n">nsparse</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ct</span> <span class="o">+</span> <span class="n">nsparse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">axes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the SparseArray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the SparseArray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Ufuncs</span>
    <span class="c1"># ------------------------------------------------------------------------</span>

    <span class="n">_HANDLED_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="p">())</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="o">+</span> <span class="n">out</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_HANDLED_TYPES</span> <span class="o">+</span> <span class="p">(</span><span class="n">SparseArray</span><span class="p">,)):</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="c1"># for binary ops, use our custom dunder methods</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">maybe_dispatch_ufunc_to_dunder_op</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># No alignment necessary.</span>
            <span class="n">sp_values</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sp_values</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># multiple outputs. e.g. modf</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span>
                        <span class="n">sp_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">SparseDtype</span><span class="p">(</span><span class="n">sp_value</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">fv</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">sp_value</span><span class="p">,</span> <span class="n">fv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sp_values</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">arrays</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span>
                <span class="n">sp_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">SparseDtype</span><span class="p">(</span><span class="n">sp_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;at&quot;</span><span class="p">:</span>
            <span class="c1"># no return value</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ------------------------------------------------------------------------</span>
    <span class="c1"># Ops</span>
    <span class="c1"># ------------------------------------------------------------------------</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_unary_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">sparse_unary_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">SparseDtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_simple_new</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;__</span><span class="si">{name}</span><span class="s2">__&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">compat</span><span class="o">.</span><span class="n">set_function_name</span><span class="p">(</span><span class="n">sparse_unary_method</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_arithmetic_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">sparse_arithmetic_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="vm">__name__</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
                <span class="c1"># Rely on pandas to dispatch to us.</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SparseArray</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_sparse_array_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">op_name</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="n">fill</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">_get_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">op_name</span> <span class="o">==</span> <span class="s2">&quot;divmod&quot;</span><span class="p">:</span>
                    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">result</span>
                    <span class="n">lfill</span><span class="p">,</span> <span class="n">rfill</span> <span class="o">=</span> <span class="n">fill</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="n">_wrap_result</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">lfill</span><span class="p">),</span>
                        <span class="n">_wrap_result</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">rfill</span><span class="p">),</span>
                    <span class="p">)</span>

                <span class="k">return</span> <span class="n">_wrap_result</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">fill</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="c1"># TODO: look into _wrap_result</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                            <span class="p">(</span>
                                <span class="s2">&quot;length mismatch: </span><span class="si">{self}</span><span class="s2"> vs. </span><span class="si">{other}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">other</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SparseArray</span><span class="p">):</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="n">other</span> <span class="o">=</span> <span class="n">SparseArray</span><span class="p">(</span>
                            <span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
                        <span class="p">)</span>
                    <span class="k">return</span> <span class="n">_sparse_array_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">op_name</span><span class="p">)</span>

        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;__</span><span class="si">{name}</span><span class="s2">__&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">compat</span><span class="o">.</span><span class="n">set_function_name</span><span class="p">(</span><span class="n">sparse_arithmetic_method</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_comparison_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">cmp_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="n">op_name</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="vm">__name__</span>

            <span class="k">if</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;and_&quot;</span><span class="p">,</span> <span class="s2">&quot;or_&quot;</span><span class="p">}:</span>
                <span class="n">op_name</span> <span class="o">=</span> <span class="n">op_name</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
                <span class="c1"># Rely on pandas to unbox and dispatch to us.</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="c1"># convert list-like to ndarray</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># TODO: make this more flexible than just ndarray...</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                        <span class="s2">&quot;length mismatch: </span><span class="si">{self}</span><span class="s2"> vs. </span><span class="si">{other}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">other</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">SparseArray</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SparseArray</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_sparse_array_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">op_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

                <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
                    <span class="n">result</span><span class="p">,</span>
                    <span class="n">sparse_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;__</span><span class="si">{name}</span><span class="s2">__&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">compat</span><span class="o">.</span><span class="n">set_function_name</span><span class="p">(</span><span class="n">cmp_method</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_unary_ops</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__pos__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_unary_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__neg__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_unary_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__invert__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_unary_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">invert</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_comparison_ops</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__and__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_comparison_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__or__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_create_comparison_method</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_add_comparison_ops</span><span class="p">()</span>

    <span class="c1"># ----------</span>
    <span class="c1"># Formatting</span>
    <span class="c1"># -----------</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{self}</span><span class="se">\n</span><span class="s2">Fill: </span><span class="si">{fill}</span><span class="se">\n</span><span class="si">{index}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">=</span><span class="n">printing</span><span class="o">.</span><span class="n">pprint_thing</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">fill</span><span class="o">=</span><span class="n">printing</span><span class="o">.</span><span class="n">pprint_thing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">printing</span><span class="o">.</span><span class="n">pprint_thing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_formatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Defer to the formatter from the GenericArrayFormatter calling us.</span>
        <span class="c1"># This will infer the correct formatter from the dtype of the values.</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="n">SparseArray</span><span class="o">.</span><span class="n">_add_arithmetic_ops</span><span class="p">()</span>
<span class="n">SparseArray</span><span class="o">.</span><span class="n">_add_comparison_ops</span><span class="p">()</span>
<span class="n">SparseArray</span><span class="o">.</span><span class="n">_add_unary_ops</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_maybe_to_dense</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    try to convert to dense</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;to_dense&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">obj</span>


<span class="k">def</span> <span class="nf">make_sparse</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;block&quot;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert ndarray to sparse format</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">    kind : {&#39;block&#39;, &#39;integer&#39;}</span>
<span class="sd">    fill_value : NaN or another value</span>
<span class="sd">    dtype : np.dtype, optional</span>
<span class="sd">    copy : bool, default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (sparse_values, index, fill_value) : (ndarray, SparseIndex, Scalar)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected dimension &lt;= 1 data&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">na_value_for_dtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">isna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># cast to object comparison to be safe</span>
        <span class="k">if</span> <span class="n">is_string_dtype</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># element-wise equality check method in numpy doesn&#39;t treat</span>
            <span class="c1"># each element type, eg. 0, 0.0, and False are treated as</span>
            <span class="c1"># same. So we have to check the both of its type and value.</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">splib</span><span class="o">.</span><span class="n">make_mask_object_ndarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">!=</span> <span class="n">fill_value</span>

    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
        <span class="c1"># the arr is a SparseArray</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">indices</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="n">index</span> <span class="o">=</span> <span class="n">_make_index</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>
    <span class="n">sparsified_values</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sparsified_values</span> <span class="o">=</span> <span class="n">astype_nansafe</span><span class="p">(</span><span class="n">sparsified_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># TODO: copy</span>
    <span class="k">return</span> <span class="n">sparsified_values</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fill_value</span>


<span class="k">def</span> <span class="nf">_make_index</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;block&quot;</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">BlockIndex</span><span class="p">):</span>
        <span class="n">locs</span><span class="p">,</span> <span class="n">lens</span> <span class="o">=</span> <span class="n">splib</span><span class="o">.</span><span class="n">get_blocks</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">BlockIndex</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">locs</span><span class="p">,</span> <span class="n">lens</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;integer&quot;</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">IntIndex</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">IntIndex</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;must be block or integer type&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">index</span>


<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1"># Accessor</span>


<span class="k">class</span> <span class="nc">BaseAccessor</span><span class="p">:</span>
    <span class="n">_validation_msg</span> <span class="o">=</span> <span class="s2">&quot;Can only use the &#39;.sparse&#39; accessor with Sparse data.&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>


<span class="nd">@delegate_names</span><span class="p">(</span>
    <span class="n">SparseArray</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;npoints&quot;</span><span class="p">,</span> <span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="s2">&quot;fill_value&quot;</span><span class="p">,</span> <span class="s2">&quot;sp_values&quot;</span><span class="p">],</span> <span class="n">typ</span><span class="o">=</span><span class="s2">&quot;property&quot;</span>
<span class="p">)</span>
<span class="k">class</span> <span class="nc">SparseAccessor</span><span class="p">(</span><span class="n">BaseAccessor</span><span class="p">,</span> <span class="n">PandasDelegate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Accessor for SparseSparse from other sparse matrix data types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">SparseDtype</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_validation_msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_delegate_property_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_delegate_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;from_coo&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_coo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;to_coo&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_coo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_coo</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dense_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a SparseSeries from a scipy.sparse.coo_matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : scipy.sparse.coo_matrix</span>
<span class="sd">        dense_index : bool, default False</span>
<span class="sd">            If False (default), the SparseSeries index consists of only the</span>
<span class="sd">            coords of the non-null entries of the original coo_matrix.</span>
<span class="sd">            If True, the SparseSeries index consists of the full sorted</span>
<span class="sd">            (row, col) coordinates of the coo_matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s : SparseSeries</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from scipy import sparse</span>
<span class="sd">        &gt;&gt;&gt; A = sparse.coo_matrix(([3.0, 1.0, 2.0], ([1, 0, 0], [0, 2, 3])),</span>
<span class="sd">                               shape=(3, 4))</span>
<span class="sd">        &gt;&gt;&gt; A</span>
<span class="sd">        &lt;3x4 sparse matrix of type &#39;&lt;class &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="sd">                with 3 stored elements in COOrdinate format&gt;</span>
<span class="sd">        &gt;&gt;&gt; A.todense()</span>
<span class="sd">        matrix([[ 0.,  0.,  1.,  2.],</span>
<span class="sd">                [ 3.,  0.,  0.,  0.],</span>
<span class="sd">                [ 0.,  0.,  0.,  0.]])</span>
<span class="sd">        &gt;&gt;&gt; ss = pd.SparseSeries.from_coo(A)</span>
<span class="sd">        &gt;&gt;&gt; ss</span>
<span class="sd">        0  2    1</span>
<span class="sd">           3    2</span>
<span class="sd">        1  0    3</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        BlockIndex</span>
<span class="sd">        Block locations: array([0], dtype=int32)</span>
<span class="sd">        Block lengths: array([3], dtype=int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.sparse.scipy_sparse</span> <span class="k">import</span> <span class="n">_coo_to_sparse_series</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">_coo_to_sparse_series</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dense_index</span><span class="o">=</span><span class="n">dense_index</span><span class="p">,</span> <span class="n">sparse_series</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to_coo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_levels</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">column_levels</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">sort_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a scipy.sparse.coo_matrix from a SparseSeries with MultiIndex.</span>

<span class="sd">        Use row_levels and column_levels to determine the row and column</span>
<span class="sd">        coordinates respectively. row_levels and column_levels are the names</span>
<span class="sd">        (labels) or numbers of the levels. {row_levels, column_levels} must be</span>
<span class="sd">        a partition of the MultiIndex level names (or numbers).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        row_levels : tuple/list</span>
<span class="sd">        column_levels : tuple/list</span>
<span class="sd">        sort_labels : bool, default False</span>
<span class="sd">            Sort the row and column labels before forming the sparse matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : scipy.sparse.coo_matrix</span>
<span class="sd">        rows : list (row labels)</span>
<span class="sd">        columns : list (column labels)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([3.0, np.nan, 1.0, 3.0, np.nan, np.nan])</span>
<span class="sd">        &gt;&gt;&gt; s.index = pd.MultiIndex.from_tuples([(1, 2, &#39;a&#39;, 0),</span>
<span class="sd">                                                (1, 2, &#39;a&#39;, 1),</span>
<span class="sd">                                                (1, 1, &#39;b&#39;, 0),</span>
<span class="sd">                                                (1, 1, &#39;b&#39;, 1),</span>
<span class="sd">                                                (2, 1, &#39;b&#39;, 0),</span>
<span class="sd">                                                (2, 1, &#39;b&#39;, 1)],</span>
<span class="sd">                                                names=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])</span>
<span class="sd">        &gt;&gt;&gt; ss = s.to_sparse()</span>
<span class="sd">        &gt;&gt;&gt; A, rows, columns = ss.to_coo(row_levels=[&#39;A&#39;, &#39;B&#39;],</span>
<span class="sd">                                         column_levels=[&#39;C&#39;, &#39;D&#39;],</span>
<span class="sd">                                         sort_labels=True)</span>
<span class="sd">        &gt;&gt;&gt; A</span>
<span class="sd">        &lt;3x4 sparse matrix of type &#39;&lt;class &#39;numpy.float64&#39;&gt;&#39;</span>
<span class="sd">                with 3 stored elements in COOrdinate format&gt;</span>
<span class="sd">        &gt;&gt;&gt; A.todense()</span>
<span class="sd">        matrix([[ 0.,  0.,  1.,  3.],</span>
<span class="sd">        [ 3.,  0.,  0.,  0.],</span>
<span class="sd">        [ 0.,  0.,  0.,  0.]])</span>
<span class="sd">        &gt;&gt;&gt; rows</span>
<span class="sd">        [(1, 1), (1, 2), (2, 1)]</span>
<span class="sd">        &gt;&gt;&gt; columns</span>
<span class="sd">        [(&#39;a&#39;, 0), (&#39;a&#39;, 1), (&#39;b&#39;, 0), (&#39;b&#39;, 1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.sparse.scipy_sparse</span> <span class="k">import</span> <span class="n">_sparse_series_to_coo</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">_sparse_series_to_coo</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span> <span class="n">row_levels</span><span class="p">,</span> <span class="n">column_levels</span><span class="p">,</span> <span class="n">sort_labels</span><span class="o">=</span><span class="n">sort_labels</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">columns</span>

    <span class="k">def</span> <span class="nf">to_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a Series from sparse values to dense.</span>

<span class="sd">        .. versionadded:: 0.25.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series:</span>
<span class="sd">            A Series with the same values, stored as a dense array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; series = pd.Series(pd.SparseArray([0, 1, 0]))</span>
<span class="sd">        &gt;&gt;&gt; series</span>
<span class="sd">        0    0</span>
<span class="sd">        1    1</span>
<span class="sd">        2    0</span>
<span class="sd">        dtype: Sparse[int64, 0]</span>

<span class="sd">        &gt;&gt;&gt; series.sparse.to_dense()</span>
<span class="sd">        0    0</span>
<span class="sd">        1    1</span>
<span class="sd">        2    0</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>

        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">SparseFrameAccessor</span><span class="p">(</span><span class="n">BaseAccessor</span><span class="p">,</span> <span class="n">PandasDelegate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DataFrame accessor for sparse data.</span>

<span class="sd">    .. versionadded :: 0.25.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtypes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">SparseDtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_validation_msg</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_spmatrix</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new DataFrame from a scipy sparse matrix.</span>

<span class="sd">        .. versionadded:: 0.25.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : scipy.sparse.spmatrix</span>
<span class="sd">            Must be convertible to csc format.</span>
<span class="sd">        index, columns : Index, optional</span>
<span class="sd">            Row and column labels to use for the resulting DataFrame.</span>
<span class="sd">            Defaults to a RangeIndex.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Each column of the DataFrame is stored as a</span>
<span class="sd">            :class:`SparseArray`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import scipy.sparse</span>
<span class="sd">        &gt;&gt;&gt; mat = scipy.sparse.eye(3)</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame.sparse.from_spmatrix(mat)</span>
<span class="sd">             0    1    2</span>
<span class="sd">        0  1.0  0.0  0.0</span>
<span class="sd">        1  0.0  1.0  0.0</span>
<span class="sd">        2  0.0  0.0  1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_prep_index</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="n">sparrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">SparseArray</span><span class="o">.</span><span class="n">from_spmatrix</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">sparrays</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a DataFrame with sparse values to dense.</span>

<span class="sd">        .. versionadded:: 0.25.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            A DataFrame with the same values stored as dense arrays.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: pd.SparseArray([0, 1, 0])})</span>
<span class="sd">        &gt;&gt;&gt; df.sparse.to_dense()</span>
<span class="sd">           A</span>
<span class="sd">        0  0</span>
<span class="sd">        1  1</span>
<span class="sd">        2  0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_coo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the contents of the frame as a sparse SciPy COO matrix.</span>

<span class="sd">        .. versionadded:: 0.25.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coo_matrix : scipy.sparse.spmatrix</span>
<span class="sd">            If the caller is heterogeneous and contains booleans or objects,</span>
<span class="sd">            the result will be of dtype=object. See Notes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The dtype will be the lowest-common-denominator type (implicit</span>
<span class="sd">        upcasting); that is to say if the dtypes (even of numeric types)</span>
<span class="sd">        are mixed, the one that accommodates all will be chosen.</span>

<span class="sd">        e.g. If the dtypes are float16 and float32, dtype will be upcast to</span>
<span class="sd">        float32. By numpy.find_common_type convention, mixing int64 and</span>
<span class="sd">        and uint64 will result in a float64 dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">import_optional_dependency</span><span class="p">(</span><span class="s2">&quot;scipy&quot;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">coo_matrix</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">find_common_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">SparseDtype</span><span class="p">):</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">subtype</span>

        <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">datas</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">sp_index</span><span class="o">.</span><span class="n">to_int_index</span><span class="p">()</span><span class="o">.</span><span class="n">indices</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)))</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="n">datas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">sp_values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
        <span class="n">datas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">datas</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coo_matrix</span><span class="p">((</span><span class="n">datas</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">density</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ratio of non-sparse points to total (dense) data points</span>
<span class="sd">        represented in the DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">column</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">density</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_prep_index</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pandas.core.indexes.base</span> <span class="k">as</span> <span class="nn">ibase</span>

        <span class="n">N</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">ibase</span><span class="o">.</span><span class="n">default_index</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">ibase</span><span class="o">.</span><span class="n">default_index</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="n">K</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Column length mismatch: </span><span class="si">{columns}</span><span class="s2"> vs. </span><span class="si">{K}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">),</span> <span class="n">K</span><span class="o">=</span><span class="n">K</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Index length mismatch: </span><span class="si">{index}</span><span class="s2"> vs. </span><span class="si">{N}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, LIP6

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>