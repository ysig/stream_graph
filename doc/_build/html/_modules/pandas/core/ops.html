

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pandas.core.ops &mdash; Stream Graph 0.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/_static/css/supplementary.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Stream Graph
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction/about.html">General Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction/installation.html">Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction/installation.html#installing-dependencies">Installing Dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction/installation.html#installing-the-master-version">Installing the master-version</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../package_walkthrough/index.html">Package Walkthrough</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Getting Started</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">ABC Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html#base-classes">Base Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html#abc-implementations">ABC Implementations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html#temporal-dataframes">Temporal-DataFrames</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html#visualizer">Visualizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html#exceptions">Exceptions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Stream Graph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pandas.core.ops</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pandas.core.ops</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Arithmetic operations for PandasObjects</span>

<span class="sd">This is not a public API.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># necessary to enforce truediv in Python 2.X</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="k">import</span> <span class="n">algos</span> <span class="k">as</span> <span class="n">libalgos</span><span class="p">,</span> <span class="n">lib</span><span class="p">,</span> <span class="n">ops</span> <span class="k">as</span> <span class="n">libops</span>
<span class="kn">import</span> <span class="nn">pandas.compat</span> <span class="k">as</span> <span class="nn">compat</span>
<span class="kn">from</span> <span class="nn">pandas.compat</span> <span class="k">import</span> <span class="n">bind_method</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="k">import</span> <span class="n">NullFrequencyError</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="k">import</span> <span class="n">Appender</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.cast</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">construct_1d_object_array_from_listlike</span><span class="p">,</span> <span class="n">find_common_type</span><span class="p">,</span>
    <span class="n">maybe_upcast_putmask</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">ensure_object</span><span class="p">,</span> <span class="n">is_bool_dtype</span><span class="p">,</span> <span class="n">is_categorical_dtype</span><span class="p">,</span> <span class="n">is_datetime64_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64tz_dtype</span><span class="p">,</span> <span class="n">is_datetimelike_v_numeric</span><span class="p">,</span> <span class="n">is_extension_array_dtype</span><span class="p">,</span>
    <span class="n">is_integer_dtype</span><span class="p">,</span> <span class="n">is_list_like</span><span class="p">,</span> <span class="n">is_object_dtype</span><span class="p">,</span> <span class="n">is_period_dtype</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span> <span class="n">is_timedelta64_dtype</span><span class="p">,</span> <span class="n">needs_i8_conversion</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">ABCDataFrame</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">,</span> <span class="n">ABCPanel</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCSparseArray</span><span class="p">,</span>
    <span class="n">ABCSparseSeries</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="k">import</span> <span class="n">isna</span><span class="p">,</span> <span class="n">notna</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">import</span> <span class="nn">pandas.core.missing</span> <span class="k">as</span> <span class="nn">missing</span>

<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Ops Wrapping Utilities</span>


<span class="k">def</span> <span class="nf">get_op_result_name</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the appropriate name to pin to an operation result.  This result</span>
<span class="sd">    should always be either an Index or a Series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : {Series, Index}</span>
<span class="sd">    right : object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    name : object</span>
<span class="sd">        Usually a string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># `left` is always a pd.Series when called from within ops</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">)):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">_maybe_match_name</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">name</span>
    <span class="k">return</span> <span class="n">name</span>


<span class="k">def</span> <span class="nf">_maybe_match_name</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Try to find a name to attach to the result of an operation between</span>
<span class="sd">    a and b.  If only one of these has a `name` attribute, return that</span>
<span class="sd">    name.  Otherwise return a consensus name if they match of None if</span>
<span class="sd">    they have different names.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : object</span>
<span class="sd">    b : object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    name : str or None</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    pandas.core.common.consensus_name_attr</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a_has</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span>
    <span class="n">b_has</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a_has</span> <span class="ow">and</span> <span class="n">b_has</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: what if they both have np.nan for their names?</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">a_has</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="n">b_has</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">name</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">maybe_upcast_for_op</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cast non-pandas objects to pandas types to unify behavior of arithmetic</span>
<span class="sd">    and comparison operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj: object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : object</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Be careful to call this *after* determining the `name` attribute to be</span>
<span class="sd">    attached to the result of the arithmetic operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">:</span>
        <span class="c1"># GH#22390  cast up to Timedelta to rely on Timedelta</span>
        <span class="c1"># implementation; otherwise operation against numeric-dtype</span>
        <span class="c1"># raises TypeError</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isna</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="c1"># In particular non-nanosecond timedelta64 needs to be cast to</span>
        <span class="c1">#  nanoseconds, or else we get undesired behavior like</span>
        <span class="c1">#  np.timedelta64(3, &#39;D&#39;) / 2 == np.timedelta64(1, &#39;D&#39;)</span>
        <span class="c1"># The isna check is to avoid casting timedelta64(&quot;NaT&quot;), which would</span>
        <span class="c1">#  return NaT and incorrectly be treated as a datetime-NaT.</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="c1"># GH#22390 Unfortunately we need to special-case right-hand</span>
        <span class="c1"># timedelta64 dtypes because numpy casts integer dtypes to</span>
        <span class="c1"># timedelta64 when operating with timedelta64</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">TimedeltaIndex</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Reversed Operations not available in the stdlib operator module.</span>
<span class="c1"># Defining these instead of using lambdas allows us to reference them by name.</span>

<span class="k">def</span> <span class="nf">radd</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">right</span> <span class="o">+</span> <span class="n">left</span>


<span class="k">def</span> <span class="nf">rsub</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>


<span class="k">def</span> <span class="nf">rmul</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">right</span> <span class="o">*</span> <span class="n">left</span>


<span class="k">def</span> <span class="nf">rdiv</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">right</span> <span class="o">/</span> <span class="n">left</span>


<span class="k">def</span> <span class="nf">rtruediv</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">right</span> <span class="o">/</span> <span class="n">left</span>


<span class="k">def</span> <span class="nf">rfloordiv</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">right</span> <span class="o">//</span> <span class="n">left</span>


<span class="k">def</span> <span class="nf">rmod</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="c1"># check if right is a string as % is the string</span>
    <span class="c1"># formatting operation; this is a TypeError</span>
    <span class="c1"># otherwise perform the op</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{typ}</span><span class="s2"> cannot perform the operation mod&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">right</span> <span class="o">%</span> <span class="n">left</span>


<span class="k">def</span> <span class="nf">rdivmod</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">rpow</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">right</span> <span class="o">**</span> <span class="n">left</span>


<span class="k">def</span> <span class="nf">rand_</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ror_</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">rxor</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span>


<span class="c1"># -----------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">make_invalid_op</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a binary method that always raises a TypeError.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    invalid_op : function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">invalid_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot perform </span><span class="si">{name}</span><span class="s2"> with this index type: &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{typ}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="n">invalid_op</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">invalid_op</span>


<span class="k">def</span> <span class="nf">_gen_eval_kwargs</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the keyword arguments to pass to numexpr for the given operation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eval_kwargs : dict</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; _gen_eval_kwargs(&quot;__add__&quot;)</span>
<span class="sd">    {}</span>

<span class="sd">    &gt;&gt;&gt; _gen_eval_kwargs(&quot;rtruediv&quot;)</span>
<span class="sd">    {&#39;reversed&#39;: True, &#39;truediv&#39;: True}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Series and Panel appear to only pass __add__, __radd__, ...</span>
    <span class="c1"># but DataFrame gets both these dunder names _and_ non-dunder names</span>
    <span class="c1"># add, radd, ...</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;radd&#39;</span><span class="p">,</span> <span class="s1">&#39;rand&#39;</span><span class="p">,</span> <span class="s1">&#39;ror&#39;</span><span class="p">,</span> <span class="s1">&#39;rxor&#39;</span><span class="p">]:</span>
            <span class="c1"># Exclude commutative operations</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;reversed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;truediv&#39;</span><span class="p">,</span> <span class="s1">&#39;rtruediv&#39;</span><span class="p">]:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;truediv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ne&#39;</span><span class="p">]:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;masker&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">_gen_fill_zeros</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the appropriate fill value to use when filling in undefined values</span>
<span class="sd">    in the results of the given operation caused by operating on</span>
<span class="sd">    (generally dividing by) zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fill_value : {None, np.nan, np.inf}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;div&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="c1"># truediv, floordiv, div, and reversed variants</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">elif</span> <span class="s1">&#39;mod&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="c1"># mod, rmod</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">fill_value</span>


<span class="k">def</span> <span class="nf">_get_frame_op_default_axis</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Only DataFrame cares about default_axis, specifically:</span>
<span class="sd">    special methods have default_axis=None and flex methods</span>
<span class="sd">    have default_axis=&#39;columns&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    default_axis: str or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;__r&#39;</span><span class="p">,</span> <span class="s1">&#39;__&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;__and__&#39;</span><span class="p">,</span> <span class="s1">&#39;__or__&#39;</span><span class="p">,</span> <span class="s1">&#39;__xor__&#39;</span><span class="p">]:</span>
        <span class="c1"># bool methods</span>
        <span class="k">return</span> <span class="s1">&#39;columns&#39;</span>
    <span class="k">elif</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">):</span>
        <span class="c1"># __add__, __mul__, ...</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># add, mul, ...</span>
        <span class="k">return</span> <span class="s1">&#39;columns&#39;</span>


<span class="k">def</span> <span class="nf">_get_opstr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the operation string, if any, to pass to numexpr for this</span>
<span class="sd">    operation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : binary operator</span>
<span class="sd">    cls : class</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    op_str : string or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># numexpr is available for non-sparse classes</span>
    <span class="n">subtyp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_subtyp&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">use_numexpr</span> <span class="o">=</span> <span class="s1">&#39;sparse&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subtyp</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_numexpr</span><span class="p">:</span>
        <span class="c1"># if we&#39;re not using numexpr, then don&#39;t pass a str_rep</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="p">{</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span>
            <span class="n">radd</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span>
            <span class="n">rmul</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">:</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span>
            <span class="n">rsub</span><span class="p">:</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">:</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span>
            <span class="n">rtruediv</span><span class="p">:</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">:</span> <span class="s1">&#39;//&#39;</span><span class="p">,</span>
            <span class="n">rfloordiv</span><span class="p">:</span> <span class="s1">&#39;//&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO: Why None for mod but &#39;%&#39; for rmod?</span>
            <span class="n">rmod</span><span class="p">:</span> <span class="s1">&#39;%&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">:</span> <span class="s1">&#39;**&#39;</span><span class="p">,</span>
            <span class="n">rpow</span><span class="p">:</span> <span class="s1">&#39;**&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">:</span> <span class="s1">&#39;==&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">:</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">:</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">:</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">:</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">:</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">:</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">,</span>
            <span class="n">rand_</span><span class="p">:</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">:</span> <span class="s1">&#39;|&#39;</span><span class="p">,</span>
            <span class="n">ror_</span><span class="p">:</span> <span class="s1">&#39;|&#39;</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">xor</span><span class="p">:</span> <span class="s1">&#39;^&#39;</span><span class="p">,</span>
            <span class="n">rxor</span><span class="p">:</span> <span class="s1">&#39;^&#39;</span><span class="p">,</span>
            <span class="nb">divmod</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">rdivmod</span><span class="p">:</span> <span class="kc">None</span><span class="p">}[</span><span class="n">op</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the name to attach to this method according to conventions</span>
<span class="sd">    for special and non-special methods.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : binary operator</span>
<span class="sd">    special : bool</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    op_name : str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">opname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">special</span><span class="p">:</span>
        <span class="n">opname</span> <span class="o">=</span> <span class="s1">&#39;__</span><span class="si">{opname}</span><span class="s1">__&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">opname</span><span class="o">=</span><span class="n">opname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">opname</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Docstring Generation and Templates</span>

<span class="n">_op_descriptions</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># Arithmetic Operators</span>
    <span class="s1">&#39;add&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span>
            <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Addition&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="s1">&#39;radd&#39;</span><span class="p">},</span>
    <span class="s1">&#39;sub&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span>
            <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Subtraction&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="s1">&#39;rsub&#39;</span><span class="p">},</span>
    <span class="s1">&#39;mul&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span>
            <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Multiplication&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="s1">&#39;rmul&#39;</span><span class="p">,</span>
            <span class="s1">&#39;df_examples&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
    <span class="s1">&#39;mod&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;%&#39;</span><span class="p">,</span>
            <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Modulo&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="s1">&#39;rmod&#39;</span><span class="p">},</span>
    <span class="s1">&#39;pow&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;**&#39;</span><span class="p">,</span>
            <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Exponential power&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="s1">&#39;rpow&#39;</span><span class="p">,</span>
            <span class="s1">&#39;df_examples&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
    <span class="s1">&#39;truediv&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span>
                <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Floating division&#39;</span><span class="p">,</span>
                <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="s1">&#39;rtruediv&#39;</span><span class="p">,</span>
                <span class="s1">&#39;df_examples&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
    <span class="s1">&#39;floordiv&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;//&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Integer division&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="s1">&#39;rfloordiv&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;df_examples&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
    <span class="s1">&#39;divmod&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;divmod&#39;</span><span class="p">,</span>
               <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Integer division and modulo&#39;</span><span class="p">,</span>
               <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="s1">&#39;rdivmod&#39;</span><span class="p">,</span>
               <span class="s1">&#39;df_examples&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>

    <span class="c1"># Comparison Operators</span>
    <span class="s1">&#39;eq&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;==&#39;</span><span class="p">,</span>
           <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Equal to&#39;</span><span class="p">,</span>
           <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
    <span class="s1">&#39;ne&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;!=&#39;</span><span class="p">,</span>
           <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Not equal to&#39;</span><span class="p">,</span>
           <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
    <span class="s1">&#39;lt&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">,</span>
           <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Less than&#39;</span><span class="p">,</span>
           <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
    <span class="s1">&#39;le&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">,</span>
           <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Less than or equal to&#39;</span><span class="p">,</span>
           <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
    <span class="s1">&#39;gt&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span>
           <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Greater than&#39;</span><span class="p">,</span>
           <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
    <span class="s1">&#39;ge&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;op&#39;</span><span class="p">:</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">,</span>
           <span class="s1">&#39;desc&#39;</span><span class="p">:</span> <span class="s1">&#39;Greater than or equal to&#39;</span><span class="p">,</span>
           <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
<span class="p">}</span>

<span class="n">_op_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_op_descriptions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_op_names</span><span class="p">:</span>
    <span class="n">_op_descriptions</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;reversed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">reverse_op</span> <span class="o">=</span> <span class="n">_op_descriptions</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;reverse&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">reverse_op</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_op_descriptions</span><span class="p">[</span><span class="n">reverse_op</span><span class="p">]</span> <span class="o">=</span> <span class="n">_op_descriptions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_op_descriptions</span><span class="p">[</span><span class="n">reverse_op</span><span class="p">][</span><span class="s1">&#39;reversed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">_op_descriptions</span><span class="p">[</span><span class="n">reverse_op</span><span class="p">][</span><span class="s1">&#39;reverse&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

<span class="n">_flex_doc_SERIES</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="si">{desc}</span><span class="s2"> of series and other, element-wise (binary operator `</span><span class="si">{op_name}</span><span class="s2">`).</span>

<span class="s2">Equivalent to ``</span><span class="si">{equiv}</span><span class="s2">``, but with support to substitute a fill_value for</span>
<span class="s2">missing data in one of the inputs.</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">other : Series or scalar value</span>
<span class="s2">fill_value : None or float value, default None (NaN)</span>
<span class="s2">    Fill existing missing (NaN) values, and any new element needed for</span>
<span class="s2">    successful Series alignment, with this value before computation.</span>
<span class="s2">    If data in both corresponding Series locations is missing</span>
<span class="s2">    the result will be missing</span>
<span class="s2">level : int or name</span>
<span class="s2">    Broadcast across a level, matching Index values on the</span>
<span class="s2">    passed MultiIndex level</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="s2">result : Series</span>

<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">Series.</span><span class="si">{reverse}</span><span class="s2"></span>

<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">&gt;&gt;&gt; a = pd.Series([1, 1, 1, np.nan], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span>
<span class="s2">&gt;&gt;&gt; a</span>
<span class="s2">a    1.0</span>
<span class="s2">b    1.0</span>
<span class="s2">c    1.0</span>
<span class="s2">d    NaN</span>
<span class="s2">dtype: float64</span>
<span class="s2">&gt;&gt;&gt; b = pd.Series([1, np.nan, 1, np.nan], index=[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;e&#39;])</span>
<span class="s2">&gt;&gt;&gt; b</span>
<span class="s2">a    1.0</span>
<span class="s2">b    NaN</span>
<span class="s2">d    1.0</span>
<span class="s2">e    NaN</span>
<span class="s2">dtype: float64</span>
<span class="s2">&gt;&gt;&gt; a.add(b, fill_value=0)</span>
<span class="s2">a    2.0</span>
<span class="s2">b    1.0</span>
<span class="s2">c    1.0</span>
<span class="s2">d    1.0</span>
<span class="s2">e    NaN</span>
<span class="s2">dtype: float64</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_arith_doc_FRAME</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Binary operator </span><span class="si">%s</span><span class="s2"> with support to substitute a fill_value for missing data in</span>
<span class="s2">one of the inputs</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">other : Series, DataFrame, or constant</span>
<span class="s2">axis : {0, 1, &#39;index&#39;, &#39;columns&#39;}</span>
<span class="s2">    For Series input, axis to match Series index on</span>
<span class="s2">fill_value : None or float value, default None</span>
<span class="s2">    Fill existing missing (NaN) values, and any new element needed for</span>
<span class="s2">    successful DataFrame alignment, with this value before computation.</span>
<span class="s2">    If data in both corresponding DataFrame locations is missing</span>
<span class="s2">    the result will be missing</span>
<span class="s2">level : int or name</span>
<span class="s2">    Broadcast across a level, matching Index values on the</span>
<span class="s2">    passed MultiIndex level</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="s2">result : DataFrame</span>

<span class="s2">Notes</span>
<span class="s2">-----</span>
<span class="s2">Mismatched indices will be unioned together</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_flex_doc_FRAME</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="si">{desc}</span><span class="s2"> of dataframe and other, element-wise (binary operator `</span><span class="si">{op_name}</span><span class="s2">`).</span>

<span class="s2">Equivalent to ``</span><span class="si">{equiv}</span><span class="s2">``, but with support to substitute a fill_value</span>
<span class="s2">for missing data in one of the inputs. With reverse version, `</span><span class="si">{reverse}</span><span class="s2">`.</span>

<span class="s2">Among flexible wrappers (`add`, `sub`, `mul`, `div`, `mod`, `pow`) to</span>
<span class="s2">arithmetic operators: `+`, `-`, `*`, `/`, `//`, `%`, `**`.</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">other : scalar, sequence, Series, or DataFrame</span>
<span class="s2">    Any single or multiple element data structure, or list-like object.</span>
<span class="s2">axis :  {{0 or &#39;index&#39;, 1 or &#39;columns&#39;}}</span>
<span class="s2">    Whether to compare by the index (0 or &#39;index&#39;) or columns</span>
<span class="s2">    (1 or &#39;columns&#39;). For Series input, axis to match Series index on.</span>
<span class="s2">level : int or label</span>
<span class="s2">    Broadcast across a level, matching Index values on the</span>
<span class="s2">    passed MultiIndex level.</span>
<span class="s2">fill_value : float or None, default None</span>
<span class="s2">    Fill existing missing (NaN) values, and any new element needed for</span>
<span class="s2">    successful DataFrame alignment, with this value before computation.</span>
<span class="s2">    If data in both corresponding DataFrame locations is missing</span>
<span class="s2">    the result will be missing.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="s2">DataFrame</span>
<span class="s2">    Result of the arithmetic operation.</span>

<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">DataFrame.add : Add DataFrames.</span>
<span class="s2">DataFrame.sub : Subtract DataFrames.</span>
<span class="s2">DataFrame.mul : Multiply DataFrames.</span>
<span class="s2">DataFrame.div : Divide DataFrames (float division).</span>
<span class="s2">DataFrame.truediv : Divide DataFrames (float division).</span>
<span class="s2">DataFrame.floordiv : Divide DataFrames (integer division).</span>
<span class="s2">DataFrame.mod : Calculate modulo (remainder after division).</span>
<span class="s2">DataFrame.pow : Calculate exponential power.</span>

<span class="s2">Notes</span>
<span class="s2">-----</span>
<span class="s2">Mismatched indices will be unioned together.</span>

<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">&gt;&gt;&gt; df = pd.DataFrame({{&#39;angles&#39;: [0, 3, 4],</span>
<span class="s2">...                    &#39;degrees&#39;: [360, 180, 360]}},</span>
<span class="s2">...                   index=[&#39;circle&#39;, &#39;triangle&#39;, &#39;rectangle&#39;])</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">           angles  degrees</span>
<span class="s2">circle          0      360</span>
<span class="s2">triangle        3      180</span>
<span class="s2">rectangle       4      360</span>

<span class="s2">Add a scalar with operator version which return the same</span>
<span class="s2">results.</span>

<span class="s2">&gt;&gt;&gt; df + 1</span>
<span class="s2">           angles  degrees</span>
<span class="s2">circle          1      361</span>
<span class="s2">triangle        4      181</span>
<span class="s2">rectangle       5      361</span>

<span class="s2">&gt;&gt;&gt; df.add(1)</span>
<span class="s2">           angles  degrees</span>
<span class="s2">circle          1      361</span>
<span class="s2">triangle        4      181</span>
<span class="s2">rectangle       5      361</span>

<span class="s2">Divide by constant with reverse version.</span>

<span class="s2">&gt;&gt;&gt; df.div(10)</span>
<span class="s2">           angles  degrees</span>
<span class="s2">circle        0.0     36.0</span>
<span class="s2">triangle      0.3     18.0</span>
<span class="s2">rectangle     0.4     36.0</span>

<span class="s2">&gt;&gt;&gt; df.rdiv(10)</span>
<span class="s2">             angles   degrees</span>
<span class="s2">circle          inf  0.027778</span>
<span class="s2">triangle   3.333333  0.055556</span>
<span class="s2">rectangle  2.500000  0.027778</span>

<span class="s2">Subtract a list and Series by axis with operator version.</span>

<span class="s2">&gt;&gt;&gt; df - [1, 2]</span>
<span class="s2">           angles  degrees</span>
<span class="s2">circle         -1      358</span>
<span class="s2">triangle        2      178</span>
<span class="s2">rectangle       3      358</span>

<span class="s2">&gt;&gt;&gt; df.sub([1, 2], axis=&#39;columns&#39;)</span>
<span class="s2">           angles  degrees</span>
<span class="s2">circle         -1      358</span>
<span class="s2">triangle        2      178</span>
<span class="s2">rectangle       3      358</span>

<span class="s2">&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=[&#39;circle&#39;, &#39;triangle&#39;, &#39;rectangle&#39;]),</span>
<span class="s2">...        axis=&#39;index&#39;)</span>
<span class="s2">           angles  degrees</span>
<span class="s2">circle         -1      359</span>
<span class="s2">triangle        2      179</span>
<span class="s2">rectangle       3      359</span>

<span class="s2">Multiply a DataFrame of different shape with operator version.</span>

<span class="s2">&gt;&gt;&gt; other = pd.DataFrame({{&#39;angles&#39;: [0, 3, 4]}},</span>
<span class="s2">...                      index=[&#39;circle&#39;, &#39;triangle&#39;, &#39;rectangle&#39;])</span>
<span class="s2">&gt;&gt;&gt; other</span>
<span class="s2">           angles</span>
<span class="s2">circle          0</span>
<span class="s2">triangle        3</span>
<span class="s2">rectangle       4</span>

<span class="s2">&gt;&gt;&gt; df * other</span>
<span class="s2">           angles  degrees</span>
<span class="s2">circle          0      NaN</span>
<span class="s2">triangle        9      NaN</span>
<span class="s2">rectangle      16      NaN</span>

<span class="s2">&gt;&gt;&gt; df.mul(other, fill_value=0)</span>
<span class="s2">           angles  degrees</span>
<span class="s2">circle          0      0.0</span>
<span class="s2">triangle        9      0.0</span>
<span class="s2">rectangle      16      0.0</span>

<span class="s2">Divide by a MultiIndex by level.</span>

<span class="s2">&gt;&gt;&gt; df_multindex = pd.DataFrame({{&#39;angles&#39;: [0, 3, 4, 4, 5, 6],</span>
<span class="s2">...                              &#39;degrees&#39;: [360, 180, 360, 360, 540, 720]}},</span>
<span class="s2">...                             index=[[&#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;],</span>
<span class="s2">...                                    [&#39;circle&#39;, &#39;triangle&#39;, &#39;rectangle&#39;,</span>
<span class="s2">...                                     &#39;square&#39;, &#39;pentagon&#39;, &#39;hexagon&#39;]])</span>
<span class="s2">&gt;&gt;&gt; df_multindex</span>
<span class="s2">             angles  degrees</span>
<span class="s2">A circle          0      360</span>
<span class="s2">  triangle        3      180</span>
<span class="s2">  rectangle       4      360</span>
<span class="s2">B square          4      360</span>
<span class="s2">  pentagon        5      540</span>
<span class="s2">  hexagon         6      720</span>

<span class="s2">&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)</span>
<span class="s2">             angles  degrees</span>
<span class="s2">A circle        NaN      1.0</span>
<span class="s2">  triangle      1.0      1.0</span>
<span class="s2">  rectangle     1.0      1.0</span>
<span class="s2">B square        0.0      0.0</span>
<span class="s2">  pentagon      0.0      0.0</span>
<span class="s2">  hexagon       0.0      0.0</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_flex_comp_doc_FRAME</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="si">{desc}</span><span class="s2"> of dataframe and other, element-wise (binary operator `</span><span class="si">{op_name}</span><span class="s2">`).</span>

<span class="s2">Among flexible wrappers (`eq`, `ne`, `le`, `lt`, `ge`, `gt`) to comparison</span>
<span class="s2">operators.</span>

<span class="s2">Equivalent to `==`, `=!`, `&lt;=`, `&lt;`, `&gt;=`, `&gt;` with support to choose axis</span>
<span class="s2">(rows or columns) and level for comparison.</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">other : scalar, sequence, Series, or DataFrame</span>
<span class="s2">    Any single or multiple element data structure, or list-like object.</span>
<span class="s2">axis :  {{0 or &#39;index&#39;, 1 or &#39;columns&#39;}}, default &#39;columns&#39;</span>
<span class="s2">    Whether to compare by the index (0 or &#39;index&#39;) or columns</span>
<span class="s2">    (1 or &#39;columns&#39;).</span>
<span class="s2">level : int or label</span>
<span class="s2">    Broadcast across a level, matching Index values on the passed</span>
<span class="s2">    MultiIndex level.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="s2">DataFrame of bool</span>
<span class="s2">    Result of the comparison.</span>

<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">DataFrame.eq : Compare DataFrames for equality elementwise.</span>
<span class="s2">DataFrame.ne : Compare DataFrames for inequality elementwise.</span>
<span class="s2">DataFrame.le : Compare DataFrames for less than inequality</span>
<span class="s2">    or equality elementwise.</span>
<span class="s2">DataFrame.lt : Compare DataFrames for strictly less than</span>
<span class="s2">    inequality elementwise.</span>
<span class="s2">DataFrame.ge : Compare DataFrames for greater than inequality</span>
<span class="s2">    or equality elementwise.</span>
<span class="s2">DataFrame.gt : Compare DataFrames for strictly greater than</span>
<span class="s2">    inequality elementwise.</span>

<span class="s2">Notes</span>
<span class="s2">--------</span>
<span class="s2">Mismatched indices will be unioned together.</span>
<span class="s2">`NaN` values are considered different (i.e. `NaN` != `NaN`).</span>

<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">&gt;&gt;&gt; df = pd.DataFrame({{&#39;cost&#39;: [250, 150, 100],</span>
<span class="s2">...                    &#39;revenue&#39;: [100, 250, 300]}},</span>
<span class="s2">...                   index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])</span>
<span class="s2">&gt;&gt;&gt; df</span>
<span class="s2">   cost  revenue</span>
<span class="s2">A   250      100</span>
<span class="s2">B   150      250</span>
<span class="s2">C   100      300</span>

<span class="s2">Comparison with a scalar, using either the operator or method:</span>

<span class="s2">&gt;&gt;&gt; df == 100</span>
<span class="s2">    cost  revenue</span>
<span class="s2">A  False     True</span>
<span class="s2">B  False    False</span>
<span class="s2">C   True    False</span>

<span class="s2">&gt;&gt;&gt; df.eq(100)</span>
<span class="s2">    cost  revenue</span>
<span class="s2">A  False     True</span>
<span class="s2">B  False    False</span>
<span class="s2">C   True    False</span>

<span class="s2">When `other` is a :class:`Series`, the columns of a DataFrame are aligned</span>
<span class="s2">with the index of `other` and broadcast:</span>

<span class="s2">&gt;&gt;&gt; df != pd.Series([100, 250], index=[&quot;cost&quot;, &quot;revenue&quot;])</span>
<span class="s2">    cost  revenue</span>
<span class="s2">A   True     True</span>
<span class="s2">B   True    False</span>
<span class="s2">C  False     True</span>

<span class="s2">Use the method to control the broadcast axis:</span>

<span class="s2">&gt;&gt;&gt; df.ne(pd.Series([100, 300], index=[&quot;A&quot;, &quot;D&quot;]), axis=&#39;index&#39;)</span>
<span class="s2">   cost  revenue</span>
<span class="s2">A  True    False</span>
<span class="s2">B  True     True</span>
<span class="s2">C  True     True</span>
<span class="s2">D  True     True</span>

<span class="s2">When comparing to an arbitrary sequence, the number of columns must</span>
<span class="s2">match the number elements in `other`:</span>

<span class="s2">&gt;&gt;&gt; df == [250, 100]</span>
<span class="s2">    cost  revenue</span>
<span class="s2">A   True     True</span>
<span class="s2">B  False    False</span>
<span class="s2">C  False    False</span>

<span class="s2">Use the method to control the axis:</span>

<span class="s2">&gt;&gt;&gt; df.eq([250, 250, 100], axis=&#39;index&#39;)</span>
<span class="s2">    cost  revenue</span>
<span class="s2">A   True    False</span>
<span class="s2">B  False     True</span>
<span class="s2">C   True    False</span>

<span class="s2">Compare to a DataFrame of different shape.</span>

<span class="s2">&gt;&gt;&gt; other = pd.DataFrame({{&#39;revenue&#39;: [300, 250, 100, 150]}},</span>
<span class="s2">...                      index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])</span>
<span class="s2">&gt;&gt;&gt; other</span>
<span class="s2">   revenue</span>
<span class="s2">A      300</span>
<span class="s2">B      250</span>
<span class="s2">C      100</span>
<span class="s2">D      150</span>

<span class="s2">&gt;&gt;&gt; df.gt(other)</span>
<span class="s2">    cost  revenue</span>
<span class="s2">A  False    False</span>
<span class="s2">B  False    False</span>
<span class="s2">C  False     True</span>
<span class="s2">D  False    False</span>

<span class="s2">Compare to a MultiIndex by level.</span>

<span class="s2">&gt;&gt;&gt; df_multindex = pd.DataFrame({{&#39;cost&#39;: [250, 150, 100, 150, 300, 220],</span>
<span class="s2">...                              &#39;revenue&#39;: [100, 250, 300, 200, 175, 225]}},</span>
<span class="s2">...                             index=[[&#39;Q1&#39;, &#39;Q1&#39;, &#39;Q1&#39;, &#39;Q2&#39;, &#39;Q2&#39;, &#39;Q2&#39;],</span>
<span class="s2">...                                    [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;]])</span>
<span class="s2">&gt;&gt;&gt; df_multindex</span>
<span class="s2">      cost  revenue</span>
<span class="s2">Q1 A   250      100</span>
<span class="s2">   B   150      250</span>
<span class="s2">   C   100      300</span>
<span class="s2">Q2 A   150      200</span>
<span class="s2">   B   300      175</span>
<span class="s2">   C   220      225</span>

<span class="s2">&gt;&gt;&gt; df.le(df_multindex, level=1)</span>
<span class="s2">       cost  revenue</span>
<span class="s2">Q1 A   True     True</span>
<span class="s2">   B   True     True</span>
<span class="s2">   C   True     True</span>
<span class="s2">Q2 A  False     True</span>
<span class="s2">   B   True    False</span>
<span class="s2">   C   True    False</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_flex_doc_PANEL</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="si">{desc}</span><span class="s2"> of series and other, element-wise (binary operator `</span><span class="si">{op_name}</span><span class="s2">`).</span>
<span class="s2">Equivalent to ``</span><span class="si">{equiv}</span><span class="s2">``.</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">other : DataFrame or Panel</span>
<span class="s2">axis : {{items, major_axis, minor_axis}}</span>
<span class="s2">    Axis to broadcast over</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="s2">Panel</span>

<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">Panel.</span><span class="si">{reverse}</span><span class="s2"></span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="n">_agg_doc_PANEL</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Wrapper method for </span><span class="si">{op_name}</span><span class="s2"></span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">other : DataFrame or Panel</span>
<span class="s2">axis : {{items, major_axis, minor_axis}}</span>
<span class="s2">    Axis to broadcast over</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="s2">Panel</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_make_flex_doc</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">typ</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make the appropriate substitutions for the given operation and class-typ</span>
<span class="sd">    into either _flex_doc_SERIES or _flex_doc_FRAME to return the docstring</span>
<span class="sd">    to attach to a generated method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op_name : str {&#39;__add__&#39;, &#39;__sub__&#39;, ... &#39;__eq__&#39;, &#39;__ne__&#39;, ...}</span>
<span class="sd">    typ : str {series, &#39;dataframe&#39;]}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    doc : str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">op_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">op_desc</span> <span class="o">=</span> <span class="n">_op_descriptions</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;reversed&#39;</span><span class="p">]:</span>
        <span class="n">equiv</span> <span class="o">=</span> <span class="s1">&#39;other &#39;</span> <span class="o">+</span> <span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;op&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">typ</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">equiv</span> <span class="o">=</span> <span class="n">typ</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;op&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; other&#39;</span>

    <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;series&#39;</span><span class="p">:</span>
        <span class="n">base_doc</span> <span class="o">=</span> <span class="n">_flex_doc_SERIES</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">base_doc</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;desc&#39;</span><span class="p">],</span> <span class="n">op_name</span><span class="o">=</span><span class="n">op_name</span><span class="p">,</span>
                              <span class="n">equiv</span><span class="o">=</span><span class="n">equiv</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;reverse&#39;</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;dataframe&#39;</span><span class="p">:</span>
        <span class="n">base_doc</span> <span class="o">=</span> <span class="n">_flex_doc_FRAME</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">base_doc</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;desc&#39;</span><span class="p">],</span> <span class="n">op_name</span><span class="o">=</span><span class="n">op_name</span><span class="p">,</span>
                              <span class="n">equiv</span><span class="o">=</span><span class="n">equiv</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;reverse&#39;</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;panel&#39;</span><span class="p">:</span>
        <span class="n">base_doc</span> <span class="o">=</span> <span class="n">_flex_doc_PANEL</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">base_doc</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;desc&#39;</span><span class="p">],</span> <span class="n">op_name</span><span class="o">=</span><span class="n">op_name</span><span class="p">,</span>
                              <span class="n">equiv</span><span class="o">=</span><span class="n">equiv</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">op_desc</span><span class="p">[</span><span class="s1">&#39;reverse&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Invalid typ argument.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">doc</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Masking NA values and fallbacks for operations numpy does not support</span>

<span class="k">def</span> <span class="nf">fill_binop</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If a non-None fill_value is given, replace null entries in left and right</span>
<span class="sd">    with this value, but only in positions where _one_ of left/right is null,</span>
<span class="sd">    not both.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : array-like</span>
<span class="sd">    right : array-like</span>
<span class="sd">    fill_value : object</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    left : array-like</span>
<span class="sd">    right : array-like</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Makes copies if fill_value is not None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: can we make a no-copy implementation?</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">left_mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># one but not both</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">left_mask</span> <span class="o">^</span> <span class="n">right_mask</span>
        <span class="n">left</span><span class="p">[</span><span class="n">left_mask</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">right</span><span class="p">[</span><span class="n">right_mask</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
    <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>


<span class="k">def</span> <span class="nf">mask_cmp_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">allowed_types</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the function `op` to only non-null points in x and y.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array-like</span>
<span class="sd">    y : array-like</span>
<span class="sd">    op : binary operation</span>
<span class="sd">    allowed_types : class or tuple of classes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : ndarray[bool]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Can we make the allowed_types arg unnecessary?</span>
    <span class="n">xrav</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">allowed_types</span><span class="p">):</span>
        <span class="n">yrav</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">xrav</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">notna</span><span class="p">(</span><span class="n">yrav</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">xrav</span><span class="p">[</span><span class="n">mask</span><span class="p">])),</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">yrav</span><span class="p">[</span><span class="n">mask</span><span class="p">])))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">xrav</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">xrav</span><span class="p">[</span><span class="n">mask</span><span class="p">])),</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">masked_arith_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If the given arithmetic operation fails, attempt it again on</span>
<span class="sd">    only the non-null elements of the input array(s).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray</span>
<span class="sd">    y : np.ndarray, Series, Index</span>
<span class="sd">    op : binary operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># For Series `x` is 1D so ravel() is a no-op; calling it anyway makes</span>
    <span class="c1"># the logic valid for both Series and DataFrame ops.</span>
    <span class="n">xrav</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)),</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">find_common_type</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># PeriodIndex.ravel() returns int64 dtype, so we have</span>
        <span class="c1"># to work around that case.  See GH#19956</span>
        <span class="n">yrav</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">is_period_dtype</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">xrav</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">notna</span><span class="p">(</span><span class="n">yrav</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">yrav</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="c1"># FIXME: GH#5284, GH#5035, GH#19448</span>
            <span class="c1"># Without specifically raising here we get mismatched</span>
            <span class="c1"># errors in Py3 (TypeError) vs Py2 (ValueError)</span>
            <span class="c1"># Note: Only = an issue in DataFrame case</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot broadcast operands together.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">xrav</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                                  <span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="n">yrav</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># mask is only meaningful for x</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">xrav</span><span class="p">)</span>

        <span class="c1"># 1 ** np.nan is 1. So we have to unmask those.</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="nb">pow</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">rpow</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">xrav</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">result</span><span class="p">,</span> <span class="n">changed</span> <span class="o">=</span> <span class="n">maybe_upcast_putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># 2D compat</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">invalid_comparison</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If a comparison has mismatched types and is not necessarily meaningful,</span>
<span class="sd">    follow python3 conventions by:</span>

<span class="sd">        - returning all-False for equality</span>
<span class="sd">        - returning all-True for inequality</span>
<span class="sd">        - raising TypeError otherwise</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : array-like</span>
<span class="sd">    right : scalar, array-like</span>
<span class="sd">    op : operator.{eq, ne, lt, le, gt}</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError : on inequality comparisons</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">:</span>
        <span class="n">res_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">:</span>
        <span class="n">res_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid comparison between dtype=</span><span class="si">{dtype}</span><span class="s2"> and </span><span class="si">{typ}</span><span class="s2">&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">right</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">res_values</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Dispatch logic</span>

<span class="k">def</span> <span class="nf">should_series_dispatch</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identify cases where a DataFrame operation should dispatch to its</span>
<span class="sd">    Series counterpart.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : DataFrame</span>
<span class="sd">    right : DataFrame</span>
<span class="sd">    op : binary operator</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    override : bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">_is_mixed_type</span> <span class="ow">or</span> <span class="n">right</span><span class="o">.</span><span class="n">_is_mixed_type</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="c1"># ensure obj.dtypes[0] exists for each obj</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">ldtype</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rdtype</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">ldtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">rdtype</span><span class="p">))</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">rdtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">ldtype</span><span class="p">))):</span>
        <span class="c1"># numpy integer dtypes as timedelta64 dtypes in this scenario</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">ldtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">rdtype</span><span class="p">):</span>
        <span class="c1"># in particular case where right is an array of DateOffsets</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">dispatch_to_series</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">str_rep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the frame operation func(left, right) by evaluating</span>
<span class="sd">    column-by-column, dispatching to the Series implementation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : DataFrame</span>
<span class="sd">    right : scalar or DataFrame</span>
<span class="sd">    func : arithmetic or comparison operator</span>
<span class="sd">    str_rep : str or None, default None</span>
<span class="sd">    axis : {None, 0, 1, &quot;index&quot;, &quot;columns&quot;}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: we use iloc to access columns for compat with cases</span>
    <span class="c1">#       with non-unique columns.</span>
    <span class="kn">import</span> <span class="nn">pandas.core.computation.expressions</span> <span class="k">as</span> <span class="nn">expressions</span>

    <span class="n">right</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">item_from_zerodim</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lib</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">column_op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">))}</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">right</span><span class="o">.</span><span class="n">_indexed_same</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">column_op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">))}</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;columns&quot;</span><span class="p">:</span>
        <span class="c1"># We only get here if called via left._combine_match_columns,</span>
        <span class="c1"># in which case we specifically want to operate row-by-row</span>
        <span class="k">assert</span> <span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">column_op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">))}</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>  <span class="c1"># Handle other cases later</span>

        <span class="k">def</span> <span class="nf">column_op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">columns</span><span class="p">))}</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Remaining cases have less-obvious dispatch rules</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

    <span class="n">new_data</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">column_op</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># Pin columns instead of passing to constructor for compat with</span>
    <span class="c1"># non-unique columns case</span>
    <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">columns</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">dispatch_to_index_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">index_class</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrap Series left in the given index_class to delegate the operation op</span>
<span class="sd">    to the index implementation.  DatetimeIndex and TimedeltaIndex perform</span>
<span class="sd">    type checking, timezone handling, overflow checks, etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : binary operator (operator.add, operator.sub, ...)</span>
<span class="sd">    left : Series</span>
<span class="sd">    right : object</span>
<span class="sd">    index_class : DatetimeIndex or TimedeltaIndex</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : object, usually DatetimeIndex, TimedeltaIndex, or Series</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">left_idx</span> <span class="o">=</span> <span class="n">index_class</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

    <span class="c1"># avoid accidentally allowing integer add/sub.  For datetime64[tz] dtypes,</span>
    <span class="c1"># left_idx may inherit a freq from a cached DatetimeIndex.</span>
    <span class="c1"># See discussion in GH#19147.</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">left_idx</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">left_idx</span> <span class="o">=</span> <span class="n">left_idx</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">left_idx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">NullFrequencyError</span><span class="p">:</span>
        <span class="c1"># DatetimeIndex and TimedeltaIndex with freq == None raise ValueError</span>
        <span class="c1"># on add/sub of integers (or int-like).  We re-raise as a TypeError.</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;incompatible type for a datetime/timedelta &#39;</span>
                        <span class="s1">&#39;operation [</span><span class="si">{name}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">dispatch_to_extension_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assume that left or right is a Series backed by an ExtensionArray,</span>
<span class="sd">    apply the operator defined by op.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># The op calls will raise TypeError if the op is not defined</span>
    <span class="c1"># on the ExtensionArray</span>

    <span class="c1"># unbox Series and Index to arrays</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
        <span class="n">new_left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_left</span> <span class="o">=</span> <span class="n">left</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
        <span class="n">new_right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">_values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="n">res_values</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">new_left</span><span class="p">,</span> <span class="n">new_right</span><span class="p">)</span>
    <span class="n">res_name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;divmod&#39;</span><span class="p">,</span> <span class="s1">&#39;rdivmod&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">_construct_divmod_result</span><span class="p">(</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">res_values</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">res_name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">res_values</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">res_name</span><span class="p">)</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Functions that add arithmetic methods to objects, given arithmetic factory</span>
<span class="c1"># methods</span>

<span class="k">def</span> <span class="nf">_get_method_wrappers</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the appropriate operation-wrappers to use when defining flex/special</span>
<span class="sd">    arithmetic, boolean, and comparison operations with the given class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls : class</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arith_flex : function or None</span>
<span class="sd">    comp_flex : function or None</span>
<span class="sd">    arith_special : function</span>
<span class="sd">    comp_special : function</span>
<span class="sd">    bool_special : function</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    None is only returned for SparseArray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCSparseSeries</span><span class="p">):</span>
        <span class="c1"># Be sure to catch this before ABCSeries and ABCSparseArray,</span>
        <span class="c1"># as they will both come see SparseSeries as a subclass</span>
        <span class="n">arith_flex</span> <span class="o">=</span> <span class="n">_flex_method_SERIES</span>
        <span class="n">comp_flex</span> <span class="o">=</span> <span class="n">_flex_method_SERIES</span>
        <span class="n">arith_special</span> <span class="o">=</span> <span class="n">_arith_method_SPARSE_SERIES</span>
        <span class="n">comp_special</span> <span class="o">=</span> <span class="n">_arith_method_SPARSE_SERIES</span>
        <span class="n">bool_special</span> <span class="o">=</span> <span class="n">_bool_method_SERIES</span>
        <span class="c1"># TODO: I don&#39;t think the functions defined by bool_method are tested</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
        <span class="c1"># Just Series; SparseSeries is caught above</span>
        <span class="n">arith_flex</span> <span class="o">=</span> <span class="n">_flex_method_SERIES</span>
        <span class="n">comp_flex</span> <span class="o">=</span> <span class="n">_flex_method_SERIES</span>
        <span class="n">arith_special</span> <span class="o">=</span> <span class="n">_arith_method_SERIES</span>
        <span class="n">comp_special</span> <span class="o">=</span> <span class="n">_comp_method_SERIES</span>
        <span class="n">bool_special</span> <span class="o">=</span> <span class="n">_bool_method_SERIES</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCSparseArray</span><span class="p">):</span>
        <span class="n">arith_flex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">comp_flex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">arith_special</span> <span class="o">=</span> <span class="n">_arith_method_SPARSE_ARRAY</span>
        <span class="n">comp_special</span> <span class="o">=</span> <span class="n">_arith_method_SPARSE_ARRAY</span>
        <span class="n">bool_special</span> <span class="o">=</span> <span class="n">_arith_method_SPARSE_ARRAY</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCPanel</span><span class="p">):</span>
        <span class="n">arith_flex</span> <span class="o">=</span> <span class="n">_flex_method_PANEL</span>
        <span class="n">comp_flex</span> <span class="o">=</span> <span class="n">_comp_method_PANEL</span>
        <span class="n">arith_special</span> <span class="o">=</span> <span class="n">_arith_method_PANEL</span>
        <span class="n">comp_special</span> <span class="o">=</span> <span class="n">_comp_method_PANEL</span>
        <span class="n">bool_special</span> <span class="o">=</span> <span class="n">_arith_method_PANEL</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
        <span class="c1"># Same for DataFrame and SparseDataFrame</span>
        <span class="n">arith_flex</span> <span class="o">=</span> <span class="n">_arith_method_FRAME</span>
        <span class="n">comp_flex</span> <span class="o">=</span> <span class="n">_flex_comp_method_FRAME</span>
        <span class="n">arith_special</span> <span class="o">=</span> <span class="n">_arith_method_FRAME</span>
        <span class="n">comp_special</span> <span class="o">=</span> <span class="n">_comp_method_FRAME</span>
        <span class="n">bool_special</span> <span class="o">=</span> <span class="n">_arith_method_FRAME</span>
    <span class="k">return</span> <span class="n">arith_flex</span><span class="p">,</span> <span class="n">comp_flex</span><span class="p">,</span> <span class="n">arith_special</span><span class="p">,</span> <span class="n">comp_special</span><span class="p">,</span> <span class="n">bool_special</span>


<span class="k">def</span> <span class="nf">_create_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arith_method</span><span class="p">,</span> <span class="n">comp_method</span><span class="p">,</span> <span class="n">bool_method</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="c1"># creates actual methods based upon arithmetic, comp and bool method</span>
    <span class="c1"># constructors.</span>

    <span class="n">have_divmod</span> <span class="o">=</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span>
    <span class="c1"># divmod is available for Series and SparseSeries</span>

    <span class="c1"># yapf: disable</span>
    <span class="n">new_methods</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">add</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">radd</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">radd</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">sub</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">mul</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">truediv</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">floordiv</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="c1"># Causes a floating point exception in the tests when numexpr enabled,</span>
        <span class="c1"># so for now no speedup</span>
        <span class="n">mod</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="nb">pow</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="c1"># not entirely sure why this is necessary, but previously was included</span>
        <span class="c1"># so it&#39;s here to maintain compatibility</span>
        <span class="n">rmul</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rmul</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">rsub</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rsub</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">rtruediv</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rtruediv</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">rfloordiv</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rfloordiv</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">rpow</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rpow</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">rmod</span><span class="o">=</span><span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rmod</span><span class="p">,</span> <span class="n">special</span><span class="p">))</span>
    <span class="c1"># yapf: enable</span>
    <span class="n">new_methods</span><span class="p">[</span><span class="s1">&#39;div&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_methods</span><span class="p">[</span><span class="s1">&#39;truediv&#39;</span><span class="p">]</span>
    <span class="n">new_methods</span><span class="p">[</span><span class="s1">&#39;rdiv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_methods</span><span class="p">[</span><span class="s1">&#39;rtruediv&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">have_divmod</span><span class="p">:</span>
        <span class="c1"># divmod doesn&#39;t have an op that is supported by numexpr</span>
        <span class="n">new_methods</span><span class="p">[</span><span class="s1">&#39;divmod&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">divmod</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
        <span class="n">new_methods</span><span class="p">[</span><span class="s1">&#39;rdivmod&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arith_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rdivmod</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>

    <span class="n">new_methods</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">eq</span><span class="o">=</span><span class="n">comp_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">ne</span><span class="o">=</span><span class="n">comp_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">lt</span><span class="o">=</span><span class="n">comp_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">gt</span><span class="o">=</span><span class="n">comp_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">le</span><span class="o">=</span><span class="n">comp_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
        <span class="n">ge</span><span class="o">=</span><span class="n">comp_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span> <span class="n">special</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">bool_method</span><span class="p">:</span>
        <span class="n">new_methods</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">and_</span><span class="o">=</span><span class="n">bool_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
                 <span class="n">or_</span><span class="o">=</span><span class="n">bool_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
                 <span class="c1"># For some reason ``^`` wasn&#39;t used in original.</span>
                 <span class="n">xor</span><span class="o">=</span><span class="n">bool_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">xor</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
                 <span class="n">rand_</span><span class="o">=</span><span class="n">bool_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rand_</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
                 <span class="n">ror_</span><span class="o">=</span><span class="n">bool_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ror_</span><span class="p">,</span> <span class="n">special</span><span class="p">),</span>
                 <span class="n">rxor</span><span class="o">=</span><span class="n">bool_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">rxor</span><span class="p">,</span> <span class="n">special</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">special</span><span class="p">:</span>
        <span class="n">dunderize</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;__</span><span class="si">{name}</span><span class="s1">__&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dunderize</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
    <span class="n">new_methods</span> <span class="o">=</span> <span class="p">{</span><span class="n">dunderize</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_methods</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">new_methods</span>


<span class="k">def</span> <span class="nf">add_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">new_methods</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">new_methods</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># For most methods, if we find that the class already has a method</span>
        <span class="c1"># of the same name, it is OK to over-write it.  The exception is</span>
        <span class="c1"># inplace methods (__iadd__, __isub__, ...) for SparseArray, which</span>
        <span class="c1"># retain the np.ndarray versions.</span>
        <span class="n">force</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ABCSparseArray</span><span class="p">)</span> <span class="ow">and</span>
                     <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__i&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">force</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="n">bind_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>


<span class="c1"># ----------------------------------------------------------------------</span>
<span class="c1"># Arithmetic</span>
<span class="k">def</span> <span class="nf">add_special_arithmetic_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds the full suite of special arithmetic methods (``__add__``,</span>
<span class="sd">    ``__sub__``, etc.) to the class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls : class</span>
<span class="sd">        special methods will be defined and pinned to this class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">arith_method</span><span class="p">,</span> <span class="n">comp_method</span><span class="p">,</span> <span class="n">bool_method</span> <span class="o">=</span> <span class="n">_get_method_wrappers</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">new_methods</span> <span class="o">=</span> <span class="n">_create_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arith_method</span><span class="p">,</span> <span class="n">comp_method</span><span class="p">,</span> <span class="n">bool_method</span><span class="p">,</span>
                                  <span class="n">special</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># inplace operators (I feel like these should get passed an `inplace=True`</span>
    <span class="c1"># or just be removed</span>

    <span class="k">def</span> <span class="nf">_wrap_inplace_method</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return an inplace wrapper for this method</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

            <span class="c1"># this makes sure that we are aligned like the input</span>
            <span class="c1"># we are updating inplace so we want to ignore is_copy</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span>
                                 <span class="n">verify_is_copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s2">&quot;__i</span><span class="si">{name}</span><span class="s2">__&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="n">new_methods</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span><span class="fm">__iadd__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__add__&quot;</span><span class="p">]),</span>
             <span class="fm">__isub__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__sub__&quot;</span><span class="p">]),</span>
             <span class="fm">__imul__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__mul__&quot;</span><span class="p">]),</span>
             <span class="fm">__itruediv__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__truediv__&quot;</span><span class="p">]),</span>
             <span class="fm">__ifloordiv__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__floordiv__&quot;</span><span class="p">]),</span>
             <span class="fm">__imod__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__mod__&quot;</span><span class="p">]),</span>
             <span class="fm">__ipow__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__pow__&quot;</span><span class="p">])))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">compat</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__idiv__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__div__&quot;</span><span class="p">])</span>

    <span class="n">new_methods</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span><span class="fm">__iand__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__and__&quot;</span><span class="p">]),</span>
             <span class="fm">__ior__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__or__&quot;</span><span class="p">]),</span>
             <span class="fm">__ixor__</span><span class="o">=</span><span class="n">_wrap_inplace_method</span><span class="p">(</span><span class="n">new_methods</span><span class="p">[</span><span class="s2">&quot;__xor__&quot;</span><span class="p">])))</span>

    <span class="n">add_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">new_methods</span><span class="o">=</span><span class="n">new_methods</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">add_flex_arithmetic_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds the full suite of flex arithmetic methods (``pow``, ``mul``, ``add``)</span>
<span class="sd">    to the class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls : class</span>
<span class="sd">        flex methods will be defined and pinned to this class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flex_arith_method</span><span class="p">,</span> <span class="n">flex_comp_method</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_method_wrappers</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">new_methods</span> <span class="o">=</span> <span class="n">_create_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">flex_arith_method</span><span class="p">,</span>
                                  <span class="n">flex_comp_method</span><span class="p">,</span> <span class="n">bool_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">special</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">new_methods</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">multiply</span><span class="o">=</span><span class="n">new_methods</span><span class="p">[</span><span class="s1">&#39;mul&#39;</span><span class="p">],</span>
                            <span class="n">subtract</span><span class="o">=</span><span class="n">new_methods</span><span class="p">[</span><span class="s1">&#39;sub&#39;</span><span class="p">],</span>
                            <span class="n">divide</span><span class="o">=</span><span class="n">new_methods</span><span class="p">[</span><span class="s1">&#39;div&#39;</span><span class="p">]))</span>
    <span class="c1"># opt out of bool flex methods for now</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">kname</span> <span class="ow">in</span> <span class="n">new_methods</span> <span class="k">for</span> <span class="n">kname</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ror_&#39;</span><span class="p">,</span> <span class="s1">&#39;rxor&#39;</span><span class="p">,</span> <span class="s1">&#39;rand_&#39;</span><span class="p">))</span>

    <span class="n">add_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">new_methods</span><span class="o">=</span><span class="n">new_methods</span><span class="p">)</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Series</span>

<span class="k">def</span> <span class="nf">_align_method_SERIES</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">align_asobject</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; align lhs and rhs Series &quot;&quot;&quot;</span>

    <span class="c1"># ToDo: Different from _align_method_FRAME, list, tuple and ndarray</span>
    <span class="c1"># are not coerced here</span>
    <span class="c1"># because Series has inconsistencies described in #13637</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
        <span class="c1"># avoid repeated alignment</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">align_asobject</span><span class="p">:</span>
                <span class="c1"># to keep original value&#39;s dtype for bool ops</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

            <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>


<span class="k">def</span> <span class="nf">_construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If the raw op result has a non-None name (e.g. it is an Index object) and</span>
<span class="sd">    the name argument is None, then passing name to the constructor will</span>
<span class="sd">    not be enough; we still need to override the name attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">out</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_construct_divmod_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;divmod returns a tuple of like indexed series instead of a single series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">constructor</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">constructor</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span>
        <span class="n">constructor</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_arith_method_SERIES</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for Series arithmetic operations, to avoid</span>
<span class="sd">    code duplication.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">str_rep</span> <span class="o">=</span> <span class="n">_get_opstr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
    <span class="n">eval_kwargs</span> <span class="o">=</span> <span class="n">_gen_eval_kwargs</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
    <span class="n">fill_zeros</span> <span class="o">=</span> <span class="n">_gen_fill_zeros</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
    <span class="n">construct_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">_construct_divmod_result</span>
                        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">divmod</span><span class="p">,</span> <span class="n">rdivmod</span><span class="p">]</span> <span class="k">else</span> <span class="n">_construct_result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pandas.core.computation.expressions</span> <span class="k">as</span> <span class="nn">expressions</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">eval_kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">masked_arith_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">fill_zeros</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">fill_zeros</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">safe_na_op</span><span class="p">(</span><span class="n">lvalues</span><span class="p">,</span> <span class="n">rvalues</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return the result of evaluating na_op on the passed in values</span>

<span class="sd">        try coercion to object type if the native types are not compatible</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lvalues : array-like</span>
<span class="sd">        rvalues : array-like</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError: invalid operation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">na_op</span><span class="p">(</span><span class="n">lvalues</span><span class="p">,</span> <span class="n">rvalues</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">lvalues</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">libalgos</span><span class="o">.</span><span class="n">arrmap_object</span><span class="p">(</span><span class="n">lvalues</span><span class="p">,</span>
                                              <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rvalues</span><span class="p">))</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">_align_method_SERIES</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="n">res_name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">maybe_upcast_for_op</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{typ}</span><span class="s2"> cannot perform the operation &quot;</span>
                            <span class="s2">&quot;</span><span class="si">{op}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">str_rep</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
            <span class="c1"># Give dispatch_to_index_op a chance for tests like</span>
            <span class="c1"># test_dt64_series_add_intlike, which the index dispatching handles</span>
            <span class="c1"># specifically.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dispatch_to_index_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span>
                                    <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">,</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">right</span><span class="p">))):</span>
            <span class="c1"># GH#22378 disallow scalar to exclude e.g. &quot;category&quot;, &quot;Int64&quot;</span>
            <span class="k">return</span> <span class="n">dispatch_to_extension_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dispatch_to_index_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">TimedeltaIndex</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span>
                                    <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="c1"># We should only get here with non-scalar or timedelta64(&#39;NaT&#39;)</span>
            <span class="c1">#  values for right</span>
            <span class="c1"># Note: we cannot use dispatch_to_index_op because</span>
            <span class="c1">#  that may incorrectly raise TypeError when we</span>
            <span class="c1">#  should get NullFrequencyError</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span>
                                    <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">,</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">lvalues</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">values</span>
        <span class="n">rvalues</span> <span class="o">=</span> <span class="n">right</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rvalues</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="n">rvalues</span> <span class="o">=</span> <span class="n">rvalues</span><span class="o">.</span><span class="n">values</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">safe_na_op</span><span class="p">(</span><span class="n">lvalues</span><span class="p">,</span> <span class="n">rvalues</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">construct_result</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span>
                                <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_comp_method_OBJECT_ARRAY</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">construct_1d_object_array_from_listlike</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndex</span><span class="p">)):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">values</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">libops</span><span class="o">.</span><span class="n">vec_compare</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">libops</span><span class="o">.</span><span class="n">scalar_compare</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_comp_method_SERIES</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for Series arithmetic operations, to avoid</span>
<span class="sd">    code duplication.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
    <span class="n">masker</span> <span class="o">=</span> <span class="n">_gen_eval_kwargs</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;masker&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="c1"># TODO:</span>
        <span class="c1"># should have guarantess on what x, y can be type-wise</span>
        <span class="c1"># Extension Dtypes are not called here</span>

        <span class="c1"># Checking that cases that were once handled here are no longer</span>
        <span class="c1"># reachable.</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_comp_method_OBJECT_ARRAY</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_datetimelike_v_numeric</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">invalid_comparison</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># we want to compare like types</span>
            <span class="c1"># we only want to convert to integer like if</span>
            <span class="c1"># we are not NotImplemented, otherwise</span>
            <span class="c1"># we would allow datetime64 (but viewed as i8) against</span>
            <span class="c1"># integer comparisons</span>

            <span class="c1"># we have a datetime/timedelta and may need to convert</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">isna</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">)</span>

            <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">invalid_comparison</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">masker</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Validate the axis parameter</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">res_name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># TODO: same for tuples?</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># Defer to DataFrame implementation; fail early</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexed_same</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only compare identically-labeled &quot;</span>
                             <span class="s2">&quot;Series objects&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># Dispatch to Categorical implementation; pd.CategoricalIndex</span>
            <span class="c1"># behavior is non-canonical GH#19513</span>
            <span class="n">res_values</span> <span class="o">=</span> <span class="n">dispatch_to_index_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                     <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># Dispatch to DatetimeIndex to ensure identical</span>
            <span class="c1"># Series/Index behavior</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">)):</span>
                <span class="c1"># https://github.com/pandas-dev/pandas/issues/21152</span>
                <span class="c1"># Compatibility for difference between Series comparison w/</span>
                <span class="c1"># datetime and date</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Comparing Series of datetimes with &#39;datetime.date&#39;.  &quot;</span>
                    <span class="s2">&quot;Currently, the &#39;datetime.date&#39; is coerced to a &quot;</span>
                    <span class="s2">&quot;datetime. In the future pandas will not coerce, &quot;</span>
                    <span class="s2">&quot;and </span><span class="si">{future}</span><span class="s2">. &quot;</span>
                    <span class="s2">&quot;To retain the current behavior, &quot;</span>
                    <span class="s2">&quot;convert the &#39;datetime.date&#39; to a datetime with &quot;</span>
                    <span class="s2">&quot;&#39;pd.Timestamp&#39;.&quot;</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">{</span><span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">}:</span>
                    <span class="n">future</span> <span class="o">=</span> <span class="s2">&quot;a TypeError will be raised&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">future</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;&#39;the values will not compare equal to the &quot;</span>
                        <span class="s2">&quot;&#39;datetime.date&#39;&quot;</span>
                    <span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">future</span><span class="o">=</span><span class="n">future</span><span class="p">)))</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="n">res_values</span> <span class="o">=</span> <span class="n">dispatch_to_index_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span>
                                              <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                     <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">res_values</span> <span class="o">=</span> <span class="n">dispatch_to_index_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span>
                                              <span class="n">pd</span><span class="o">.</span><span class="n">TimedeltaIndex</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                     <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span>
              <span class="p">(</span><span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">))):</span>
            <span class="c1"># Note: the `not is_scalar(other)` condition rules out</span>
            <span class="c1"># e.g. other == &quot;category&quot;</span>
            <span class="k">return</span> <span class="n">dispatch_to_extension_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="c1"># By this point we have checked that self._indexed_same(other)</span>
            <span class="n">res_values</span> <span class="o">=</span> <span class="n">na_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="c1"># rename is needed in case res_name is None and res_values.name</span>
            <span class="c1"># is not.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                     <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">)):</span>
            <span class="c1"># do not check length of zerodim array</span>
            <span class="c1"># as it will broadcast</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Lengths must match to compare&#39;</span><span class="p">)</span>

            <span class="n">res_values</span> <span class="o">=</span> <span class="n">na_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="c1"># rename is needed in case res_name is None and self.name</span>
            <span class="c1"># is not.</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">res_name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isna</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="c1"># numpy does not like comparisons vs None</span>
            <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">:</span>
                <span class="n">res_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                     <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">()</span>

            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">na_op</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Could not compare </span><span class="si">{typ}</span><span class="s1"> type with Series&#39;</span>
                                <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

            <span class="c1"># always return a full value series here</span>
            <span class="n">res_values</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">values_from_object</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                     <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_bool_method_SERIES</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for Series arithmetic operations, to avoid</span>
<span class="sd">    code duplication.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># bool-bool dtype operations should be OK, should not get here</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">ensure_object</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">ensure_object</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">libops</span><span class="o">.</span><span class="n">vec_binop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># let null fall thru</span>
                <span class="k">assert</span> <span class="n">lib</span><span class="o">.</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">isna</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">libops</span><span class="o">.</span><span class="n">scalar_binop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">,</span>
                        <span class="ne">OverflowError</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot compare a dtyped [</span><span class="si">{dtype}</span><span class="s2">] array &quot;</span>
                                    <span class="s2">&quot;with a scalar of type [</span><span class="si">{typ}</span><span class="s2">]&quot;</span>
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                            <span class="n">typ</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="n">fill_int</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">fill_bool</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">is_self_int_dtype</span> <span class="o">=</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">_align_method_SERIES</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">align_asobject</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">res_name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="c1"># Defer to DataFrame implementation; fail early</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCIndexClass</span><span class="p">)):</span>
            <span class="n">is_other_int_dtype</span> <span class="o">=</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">fill_int</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_other_int_dtype</span> <span class="k">else</span> <span class="n">fill_bool</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="n">ovalues</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span>
            <span class="n">finalizer</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># scalars, list, tuple, np.array</span>
            <span class="n">is_other_int_dtype</span> <span class="o">=</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># TODO: Can we do this before the is_integer_dtype check?</span>
                <span class="c1"># could the is_integer_dtype check be checking the wrong</span>
                <span class="c1"># thing?  e.g. other = [[0, 1], [2, 3], [4, 5]]?</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">construct_1d_object_array_from_listlike</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="n">ovalues</span> <span class="o">=</span> <span class="n">other</span>
            <span class="n">finalizer</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># For int vs int `^`, `|`, `&amp;` are bitwise operators and return</span>
        <span class="c1">#   integer dtypes.  Otherwise these are boolean ops</span>
        <span class="n">filler</span> <span class="o">=</span> <span class="p">(</span><span class="n">fill_int</span> <span class="k">if</span> <span class="n">is_self_int_dtype</span> <span class="ow">and</span> <span class="n">is_other_int_dtype</span>
                  <span class="k">else</span> <span class="n">fill_bool</span><span class="p">)</span>
        <span class="n">res_values</span> <span class="o">=</span> <span class="n">na_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ovalues</span><span class="p">)</span>
        <span class="n">unfilled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res_values</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">res_name</span><span class="p">)</span>
        <span class="n">filled</span> <span class="o">=</span> <span class="n">filler</span><span class="p">(</span><span class="n">unfilled</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">finalizer</span><span class="p">(</span><span class="n">filled</span><span class="p">)</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_flex_method_SERIES</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
    <span class="n">doc</span> <span class="o">=</span> <span class="n">_make_flex_doc</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;series&#39;</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">flex_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># validate axis</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binop</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Lengths must be equal&#39;</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binop</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">flex_wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">flex_wrapper</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># DataFrame</span>


<span class="k">def</span> <span class="nf">_combine_series_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply binary operator `func` to self, other using alignment and fill</span>
<span class="sd">    conventions determined by the fill_value, axis, and level kwargs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    self : DataFrame</span>
<span class="sd">    other : Series</span>
<span class="sd">    func : binary operator</span>
<span class="sd">    fill_value : object, default None</span>
<span class="sd">    axis : {0, 1, &#39;columns&#39;, &#39;index&#39;, None}, default None</span>
<span class="sd">    level : int or None, default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;fill_value </span><span class="si">{fill}</span><span class="s2"> not supported.&quot;</span>
                                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fill</span><span class="o">=</span><span class="n">fill_value</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_match_index</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_match_columns</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># Ambiguous case, use _series so works with DataFrame</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_series</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                     <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># default axis is columns</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_match_columns</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_align_method_FRAME</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; convert rhs to meet lhs dims if input is list, tuple or np.ndarray &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">to_series</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Unable to coerce to Series, length must be </span><span class="si">{req_len}</span><span class="s1">: &#39;</span>
               <span class="s1">&#39;given </span><span class="si">{given_len}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">left</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;index&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">req_len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">),</span>
                                            <span class="n">given_len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)))</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">req_len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span>
                                            <span class="n">given_len</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)))</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">right</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">right</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">to_series</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">right</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">right</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                          <span class="n">columns</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Broadcast across columns</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">right</span><span class="p">,</span>
                                          <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                          <span class="n">columns</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Broadcast along rows</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">to_series</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to coerce to DataFrame, shape &quot;</span>
                                 <span class="s2">&quot;must be </span><span class="si">{req_shape}</span><span class="s2">: given </span><span class="si">{given_shape}</span><span class="s2">&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">req_shape</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                         <span class="n">given_shape</span><span class="o">=</span><span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">right</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unable to coerce to Series/DataFrame, dim &#39;</span>
                             <span class="s1">&#39;must be &lt;= 2: </span><span class="si">{dim}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">right</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">elif</span> <span class="p">(</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="ow">and</span>
          <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">))):</span>
        <span class="c1"># GH17901</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">to_series</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">right</span>


<span class="k">def</span> <span class="nf">_arith_method_FRAME</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="n">str_rep</span> <span class="o">=</span> <span class="n">_get_opstr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
    <span class="n">eval_kwargs</span> <span class="o">=</span> <span class="n">_gen_eval_kwargs</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
    <span class="n">fill_zeros</span> <span class="o">=</span> <span class="n">_gen_fill_zeros</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
    <span class="n">default_axis</span> <span class="o">=</span> <span class="n">_get_frame_op_default_axis</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pandas.core.computation.expressions</span> <span class="k">as</span> <span class="nn">expressions</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">eval_kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">masked_arith_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">fill_zeros</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">fill_zeros</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">if</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">_op_descriptions</span><span class="p">:</span>
        <span class="c1"># i.e. include &quot;add&quot; but not &quot;__add__&quot;</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">_make_flex_doc</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="s1">&#39;dataframe&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">_arith_doc_FRAME</span> <span class="o">%</span> <span class="n">op_name</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">default_axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">_align_method_FRAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="c1"># Another DataFrame</span>
            <span class="n">pass_op</span> <span class="o">=</span> <span class="n">op</span> <span class="k">if</span> <span class="n">should_series_dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span> <span class="k">else</span> <span class="n">na_op</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_frame</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">pass_op</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="c1"># For these values of `axis`, we end up dispatching to Series op,</span>
            <span class="c1"># so do not want the masked op.</span>
            <span class="n">pass_op</span> <span class="o">=</span> <span class="n">op</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="k">else</span> <span class="n">na_op</span>
            <span class="k">return</span> <span class="n">_combine_series_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">pass_op</span><span class="p">,</span>
                                         <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                         <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_const</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>

    <span class="k">return</span> <span class="n">f</span>


<span class="k">def</span> <span class="nf">_flex_comp_method_FRAME</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="n">str_rep</span> <span class="o">=</span> <span class="n">_get_opstr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
    <span class="n">default_axis</span> <span class="o">=</span> <span class="n">_get_frame_op_default_axis</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">mask_cmp_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">doc</span> <span class="o">=</span> <span class="n">_flex_comp_doc_FRAME</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op_name</span><span class="o">=</span><span class="n">op_name</span><span class="p">,</span>
                                      <span class="n">desc</span><span class="o">=</span><span class="n">_op_descriptions</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="s1">&#39;desc&#39;</span><span class="p">])</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">default_axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">_align_method_FRAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="c1"># Another DataFrame</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexed_same</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">,</span>
                                         <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dispatch_to_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">na_op</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_combine_series_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">na_op</span><span class="p">,</span>
                                         <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                         <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">other</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_const</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">na_op</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>

    <span class="k">return</span> <span class="n">f</span>


<span class="k">def</span> <span class="nf">_comp_method_FRAME</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="n">str_rep</span> <span class="o">=</span> <span class="n">_get_opstr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="s1">&#39;Wrapper for comparison method </span><span class="si">{name}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">op_name</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">_align_method_FRAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="c1"># Another DataFrame</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexed_same</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can only compare identically-labeled &#39;</span>
                                 <span class="s1">&#39;DataFrame objects&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dispatch_to_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_combine_series_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span>
                                         <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># straight boolean comparisons we want to allow all columns</span>
            <span class="c1"># (regardless of dtype to pass thru) See #4537 for discussion.</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_const</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>

    <span class="k">return</span> <span class="n">f</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Panel</span>

<span class="k">def</span> <span class="nf">_arith_method_PANEL</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="c1"># work only for scalars</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Simple arithmetic with </span><span class="si">{name}</span><span class="s1"> can only be &#39;</span>
                             <span class="s1">&#39;done with scalar values&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>
    <span class="k">return</span> <span class="n">f</span>


<span class="k">def</span> <span class="nf">_comp_method_PANEL</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="n">str_rep</span> <span class="o">=</span> <span class="n">_get_opstr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pandas.core.computation.expressions</span> <span class="k">as</span> <span class="nn">expressions</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">mask_cmp_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="s1">&#39;Wrapper for comparison method </span><span class="si">{name}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">op_name</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Validate the axis parameter</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compare_constructor</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">na_op</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">,</span>
                                <span class="n">ABCSeries</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;input needs alignment for this object [</span><span class="si">{object}</span><span class="s2">]&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">object</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_const</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">na_op</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>

    <span class="k">return</span> <span class="n">f</span>


<span class="k">def</span> <span class="nf">_flex_method_PANEL</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="n">str_rep</span> <span class="o">=</span> <span class="n">_get_opstr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>
    <span class="n">eval_kwargs</span> <span class="o">=</span> <span class="n">_gen_eval_kwargs</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>
    <span class="n">fill_zeros</span> <span class="o">=</span> <span class="n">_gen_fill_zeros</span><span class="p">(</span><span class="n">op_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">na_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pandas.core.computation.expressions</span> <span class="k">as</span> <span class="nn">expressions</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">str_rep</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                                          <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span>
                                          <span class="o">**</span><span class="n">eval_kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># handles discrepancy between numpy and numexpr on division/mod</span>
        <span class="c1"># by 0 though, given that these are generally (always?)</span>
        <span class="c1"># non-scalars, I&#39;m not sure whether it&#39;s worth it at the moment</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">fill_zeros</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">fill_zeros</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">if</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">_op_descriptions</span><span class="p">:</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">_make_flex_doc</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="s1">&#39;panel&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># doc strings substitors</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">_agg_doc_PANEL</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op_name</span><span class="o">=</span><span class="n">op_name</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">na_op</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>
    <span class="k">return</span> <span class="n">f</span>


<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Sparse</span>

<span class="k">def</span> <span class="nf">_cast_sparse_series_op</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">opname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For SparseSeries operation, coerce to float64 if the result is expected</span>
<span class="sd">    to have NaN or inf values</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    left : SparseArray</span>
<span class="sd">    right : SparseArray</span>
<span class="sd">    opname : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    left : SparseArray</span>
<span class="sd">    right : SparseArray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">pandas.core.sparse.api</span> <span class="k">import</span> <span class="n">SparseDtype</span>

    <span class="n">opname</span> <span class="o">=</span> <span class="n">opname</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>

    <span class="c1"># TODO: This should be moved to the array?</span>
    <span class="k">if</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
        <span class="c1"># series coerces to float64 if result should have NaN/inf</span>
        <span class="k">if</span> <span class="n">opname</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;floordiv&#39;</span><span class="p">,</span> <span class="s1">&#39;mod&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">SparseDtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">SparseDtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">opname</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;rfloordiv&#39;</span><span class="p">,</span> <span class="s1">&#39;rmod&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">SparseDtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">SparseDtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">fill_value</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>


<span class="k">def</span> <span class="nf">_arith_method_SPARSE_SERIES</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for Series arithmetic operations, to avoid</span>
<span class="sd">    code duplication.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ABCSparseSeries</span><span class="p">):</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_sparse</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_sparse_series_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">op_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                     <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;operation with </span><span class="si">{other}</span><span class="s1"> not supported&#39;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_sparse_series_op</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">new_index</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span>
    <span class="n">new_name</span> <span class="o">=</span> <span class="n">get_op_result_name</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">pandas.core.arrays.sparse</span> <span class="k">import</span> <span class="n">_sparse_array_op</span>
    <span class="n">lvalues</span><span class="p">,</span> <span class="n">rvalues</span> <span class="o">=</span> <span class="n">_cast_sparse_series_op</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_sparse_array_op</span><span class="p">(</span><span class="n">lvalues</span><span class="p">,</span> <span class="n">rvalues</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">new_name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_arith_method_SPARSE_ARRAY</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function for Series arithmetic operations, to avoid</span>
<span class="sd">    code duplication.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">op_name</span> <span class="o">=</span> <span class="n">_get_op_name</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">special</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.arrays.sparse.array</span> <span class="k">import</span> <span class="p">(</span>
            <span class="n">SparseArray</span><span class="p">,</span> <span class="n">_sparse_array_op</span><span class="p">,</span> <span class="n">_wrap_result</span><span class="p">,</span> <span class="n">_get_fill</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;length mismatch: </span><span class="si">{self}</span><span class="s2"> vs. </span><span class="si">{other}</span><span class="s2">&quot;</span>
                                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">other</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SparseArray</span><span class="p">):</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">SparseArray</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_sparse_array_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">op_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">fill</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">_get_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_values</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">_wrap_result</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sp_index</span><span class="p">,</span> <span class="n">fill</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;operation with </span><span class="si">{other}</span><span class="s1"> not supported&#39;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">op_name</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, LIP6

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../../',
              VERSION:'0.2',
              LANGUAGE:'en',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>